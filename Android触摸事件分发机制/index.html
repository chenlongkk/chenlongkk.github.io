<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个Android开发者的成长记录"><title>Android触摸事件分发机制 | chenlong's</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?c429fdd6ac00b6f7e59c44c7b27894b8";
var s = document.getElementsByTagName("script")[0]; 
s.parentNode.insertBefore(hm, s);
})();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android触摸事件分发机制</h1><a id="logo" href="/.">chenlong's</a><p class="description">Android开发技术博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 全部</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android触摸事件分发机制</h1><div class="post-meta">Sep 1, 2017<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="post-content"><blockquote>
<p>虽然网上已经有很多的分析文章，但是对于这个知识点每个人都有自己的理解方式，所以只有分析一遍代码，才能理解事件传递的机制，死记硬背是没有用的，本文旨在记录我的分析过程，对其他人仅供参考。</p>
</blockquote>
<h2 id="0x01-事件传递的入口在哪里"><a href="#0x01-事件传递的入口在哪里" class="headerlink" title="0x01 事件传递的入口在哪里"></a>0x01 事件传递的入口在哪里</h2><p>网上的很多文章都说事件传递的入口在Activity的dispatchTouchEvent。我们跟一下代码其实就可以知道，从应用进程的角度来看，这并不是事件传递的入口，只是我们能够处理Event的入口。那么对应用进程来说，事件传递的入口在哪里呢？我们知道Activity展示在屏幕上的实际上是一个View，在Activity创建的时候通过创建PhoneWindow的实例，向WindowManager申请添加一个窗口，进而把自己的DecorView显示在屏幕上。屏幕接收触摸的物理事件，通过WindowManger向应用传递，那么对于应用进程而言，接收事件的入口一定是在和WindowManager发生关系的地方，我们知道这个类叫ViewRootImpl，它持有了应用进程和WindowManager的一个Binder连接，WindowSession。具体来说，它是这样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//WindowManagerGlobal.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></div><div class="line"><span class="function"><span class="params">            Display display, Window parentWindow)</span> </span>&#123;</div><div class="line">    <span class="comment">//创建ViewRootImpl的实例，它在应用侧管理了和WindowManager的交互</span></div><div class="line">    root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</div><div class="line"></div><div class="line">    view.setLayoutParams(wparams);</div><div class="line">    </div><div class="line">    <span class="comment">//经典的三个List，分别存放当前进程所有添加的Window</span></div><div class="line">    mViews.add(view);</div><div class="line">    mRoots.add(root);</div><div class="line">    mParams.add(wparams);</div><div class="line">    </div><div class="line">    <span class="comment">//创建WindowSession，向WindowManager申请展示View</span></div><div class="line">    root.setView(view, wparams, panelParentView);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ViewRootImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</div><div class="line">    <span class="comment">//创建应用进程和WindowManager的传递事件的通信通道，内部使用Pipe实现</span></div><div class="line">    mInputChannel = <span class="keyword">new</span> InputChannel();</div><div class="line">    <span class="comment">//向WindowManager中添加待展示的View</span></div><div class="line">    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</div><div class="line">                            getHostVisibility(), mDisplay.getDisplayId(),</div><div class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</div><div class="line">                            mAttachInfo.mOutsets, mInputChannel);</div><div class="line">    <span class="comment">//创建事件接受者</span></div><div class="line">    mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,Looper.myLooper());           </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>InputEventReceiver</code>是系统提供的一个用来接收输入事件的类，这里的输入事件应该指的是所有输入事件，不单是触摸事件。<code>WindowInputEventReceiver</code>继承自它，复写了<code>onInputEvent</code>,<code>onBatchedInputEventPending</code>,<code>dispose</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Called when an input event is received.</span></div><div class="line"><span class="comment"> * The recipient should process the input event and then call &#123;<span class="doctag">@link</span> #finishInputEvent&#125;</span></div><div class="line"><span class="comment"> * to indicate whether the event was handled.  No new input events will be received</span></div><div class="line"><span class="comment"> * until &#123;<span class="doctag">@link</span> #finishInputEvent&#125; is called.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 当接收到一个输入事件时会回调这个方法，接受者在处理完这个事件后，应该调用&#123;finishInputEvent&#125;</span></div><div class="line"><span class="comment"> * 方法标明这个事件已经处理了。在没有调用finishInputEvent之前，接受者不会接收到其他事件。</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> event The input event that was received.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputEvent</span><span class="params">(InputEvent event)</span> </span>&#123;</div><div class="line">    finishInputEvent(event, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Called when a batched input event is pending.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The batched input event will continue to accumulate additional movement</span></div><div class="line"><span class="comment"> * samples until the recipient calls &#123;<span class="doctag">@link</span> #consumeBatchedInputEvents&#125; or</span></div><div class="line"><span class="comment"> * an event is received that ends the batch and causes it to be consumed</span></div><div class="line"><span class="comment"> * immediately (such as a pointer up event).</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBatchedInputEventPending</span><span class="params">()</span> </span>&#123;</div><div class="line">    consumeBatchedInputEvents(-<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当接收到WindowManager传来的输入事件后，会回调<code>WindowInputEventReceiver</code>的onInputEvent方法，之后再ViewRootImpl中经过层层调用，中间的过程我们暂且搁置，最终会执行这样一行代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> handled = mView.dispatchPointerEvent(event);</div></pre></td></tr></table></figure>
<p>对于Activity来说，mView即是DecorView。DecorView是一个FrameLayout，是一个View的子类，因此我们从View的dispatchPointerEvent方法开始看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">dispatchPointerEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="comment">//如果是触摸事件，那么调用dispatchTouchEvent</span></div><div class="line">    <span class="keyword">if</span> (event.isTouchEvent()) &#123;</div><div class="line">        <span class="keyword">return</span> dispatchTouchEvent(event);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> dispatchGenericMotionEvent(event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DecorView复写了View的dispatchTouchEvent方法，我们来看一下它的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="comment">//PhoneWindow的getCallback返回当前PhoneWindow的Activity</span></div><div class="line">    <span class="keyword">final</span> Callback cb = getCallback();</div><div class="line">    <span class="comment">//如果是Activity的话，mFeatureId = -1，所以这里简单点看就是执行</span></div><div class="line">    <span class="comment">//return cb.dispatchTouchEvent(ev);</span></div><div class="line">    <span class="keyword">return</span> cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed() &amp;&amp; mFeatureId &lt; <span class="number">0</span> ? cb.dispatchTouchEvent(ev)</div><div class="line">                    : <span class="keyword">super</span>.dispatchTouchEvent(ev);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此，我们进入到了我们能够处理的阶段，也就是通常说的事件分发的入口。</p>
<h2 id="0x02-事件分发机制"><a href="#0x02-事件分发机制" class="headerlink" title="0x02 事件分发机制"></a>0x02 事件分发机制</h2><p>对于触摸事件的分配，在Activity和ViewGroup中，我们有如下的伪代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Activity</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(ViewGroup.dispatchTouchEvent(event)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> onTouchEvent(event);</div><div class="line">&#125;</div><div class="line"><span class="comment">//ViewGroup.java</span></div><div class="line"><span class="comment">//触摸事件的消费者</span></div><div class="line"><span class="keyword">private</span> TouchTarget mFirstTouchTarget</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> interupt = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span>(event.isAction_Down() || mFirstTouchTarget != <span class="keyword">null</span>)&#123;</div><div class="line">       <span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">         interupt = onInteruptTouchEvent(event);</div><div class="line">       &#125;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      interupt = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span>(!interupt) &#123;</div><div class="line">      <span class="keyword">if</span>(even.isAction_Down())&#123;</div><div class="line">        <span class="keyword">for</span>(View v : mChildren)&#123;</div><div class="line">        <span class="keyword">if</span>(v.dispatchTouchEvent(event)) &#123;</div><div class="line">          mFirstTouchTarget = v;</div><div class="line">          alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">          <span class="keyword">break</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(mFirstTouchTarget == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">if</span>(!alreadyDispatchedToNewTouchTarget)&#123;</div><div class="line">        <span class="keyword">return</span> mFirstTouchTarget.target.dispatchTouchEvent(event);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一次触摸操作由一次Action_DOWN，若干个Action_MOVE，和一次Action_UP组成。需要经过如图所示的层次来处理。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fj9u31x0mqj30vi0a4wez.jpg" alt=""></p>
<p><code>Action_DOWN</code>的作用比较关键，消费它确定了事件最深能够传递到哪一层，对于任意一次触摸操作，如果ViewGroup节点不拦截<code>ACTION_DOWN</code>事件，那么<code>ACTION_DOWN</code>将会逐层调用ViewGroup的<code>dispatchTouchEvent</code>，直到最后一个View节点，调用它的<code>onTouch</code>方法。如果最后一个View依然没有消费<code>ACTION_DOWN</code>事件，那么这个<code>ACTION_DOWN</code>事件将逐层返回视图树，调用ViewGroup的<code>onTouch</code>方法，直到最后，视图树中没有消费<code>ACTION_DOWN</code>，则交给Activity处理。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fj9v5esp2kj30xg0cgwfu.jpg" alt=""></p>
<p>我们来看几种情况:</p>
<h4 id="1-View消费ACTION-DOWN"><a href="#1-View消费ACTION-DOWN" class="headerlink" title="1. View消费ACTION_DOWN"></a>1. View消费<code>ACTION_DOWN</code></h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fj9vgpocssj30xc0c4t9v.jpg" alt=""></p>
<p>此时事件最深可以传递到最后一个View节点，那么后续的事件也会传递到View节点。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fj9vu2seimj30xa0b8gmy.jpg" alt=""></p>
<p>这里有一点需要注意，如果View不消费后续的事件，那么后续事件将交给Activity处理，而不会经由ViewGroup向上传递。</p>
<h4 id="2-ViewGroup消费ACTION-DOWN-1"><a href="#2-ViewGroup消费ACTION-DOWN-1" class="headerlink" title="2. ViewGroup消费ACTION_DOWN(1)"></a>2. ViewGroup消费<code>ACTION_DOWN</code>(1)</h4><p>ViewGroup消费<code>ACTION_DOWN</code>有两种方式，我们先看第一种，在遍历到最后一个View节点之后，仍然没有消费<code>ACTION_DOWN</code>时，此时会由底向上的调用<code>onTouchEvent</code>方法，询问ViewGroup是否消费<code>ACTION_DOWN</code>。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fj9vz2dwv5j30xa0ca75j.jpg" alt=""></p>
<p>此时，事件最深可以传递到倒数第二个节点上，那么后续的事件也就只能传递到倒数第二个节点上。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fj9w6tjjxmj30xa0bo3zv.jpg" alt=""></p>
<p>同样的，它没有消费的事件将直接交给Activity处理。</p>
<h3 id="3-ViewGroup拦截事件"><a href="#3-ViewGroup拦截事件" class="headerlink" title="3. ViewGroup拦截事件"></a>3. ViewGroup拦截事件</h3><p>在上面的分析中，我们看到ViewGroup如果想要消费事件，一定要等到View节点尝试消费之后才有机会，那么ViewGroup能不能直接消费事件呢？当然是可以的，要做到这一点，我们需要借助<code>onInteruptTouchEvent</code>方法。对于任意事件，如果ViewGroup拦截了这个事件，那么后续的事件将不会向下传递。但是，拦截并不代表消费，上面的结论依然是成立的，在哪一个节点消费<code>ACTION_DOWN</code>决定了后续事件最深能够传递到哪一层的节点。</p>
<p>这里又可以细分为两种情况，拦截<code>ACTION_DOWN</code>事件和非<code>ACTION_DOWN</code>事件。</p>
<h4 id="1-拦截ACTION-DOWN"><a href="#1-拦截ACTION-DOWN" class="headerlink" title="1. 拦截ACTION_DOWN"></a>1. 拦截<code>ACTION_DOWN</code></h4><p><strong>拦截并消费</strong></p>
<p>如果一个ViewGroup拦截，并消费了<code>ACTION_DOWN</code>事件，那么后续的事件将交由这个节点处理，该节点没有消费的事件将交给Activity处理。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fj9wu86ub6j30xc0bmdh9.jpg" alt=""></p>
<p><strong>拦截不消费</strong></p>
<p>如果ViewGroup拦截了<code>ACTION_DOWN</code>事件，但是没有消费，那么结合上面的分析结论，此时<code>ACTION_DOWN</code>将逐层返回视图树，调用它的父节点的<code>onTouchEvent</code>，一层一层的返回，如果到最顶级的ViewGroup依然没有消费<code>ACTION_DOWN</code>，那么交给Activity处理，后续的事件的处理，参考上面的分析。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fj9x2qkwjyj30xa0bsabn.jpg" alt=""></p>
<h4 id="2-拦截非ACTION-DOWN"><a href="#2-拦截非ACTION-DOWN" class="headerlink" title="2. 拦截非ACTION_DOWN"></a>2. 拦截非<code>ACTION_DOWN</code></h4><p>假设这样一种情况，首先View节点消费了<code>ACTION_DOWN</code>事件，此时后续事件最深将传递到View节点，但是当某种条件触发之后，View的父节点拦截了<code>ACTION_MOVE</code>事件，那么原有的消费事件的节点会首先受到一个<code>ACTION_CANCE</code>，然后，后续事件都将由父节点处理，父节点即使不消费这些事件，也会直接交给Activity处理。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fj9zb4keoyj30xa0c6jsk.jpg" alt=""></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fj9zi0dfy5j30xa0b2wg0.jpg" alt=""></p>
<h4 id="requestDisallowInterceptTouchEvent"><a href="#requestDisallowInterceptTouchEvent" class="headerlink" title="requestDisallowInterceptTouchEvent"></a>requestDisallowInterceptTouchEvent</h4><p>正常情况下，子节点是不能控制父节点消费事件的，这个方法可以由子节点调用，屏蔽父节点对非<code>ACTION_DOWN</code>事件的拦截，因为父节点对每次<code>ACTION_DOWN</code>都会重置这个标志位。</p>
<h3 id="0x03-结论"><a href="#0x03-结论" class="headerlink" title="0x03 结论"></a>0x03 结论</h3><ol>
<li>一次触摸事件由ACTION_DOWN，ACTION_MOVE, ACTION_UP组成。</li>
<li>ACTION_DOWN决定了由哪一个View消费事件，一旦分配了消费事件View，那么后续的ACTION都会传递到这个View处理。</li>
<li>如果一个View消费了Action_Down，但是没有消费后续的事件，那么这些后续事件不会由它的父元素处理，而是由Activity处理。</li>
<li>如果一个ViweGruop中，没有分配消费事件的View，那么会询问ViewGroup是否消费事件。如果消费事件，则后续的事件有ViewGruop消费，如果不消费，则事件继续向上传递，直到从便利到顶部的ViewGruop，如果顶部ViewGroup也不消费，则交给Activity。</li>
<li>由于Action_Down决定了后续的事件由谁消费，因此ViewGroup有机会拦截这个事件，阻止事件继续传递，即onInterceptTouchEvent返回true，此时事件不会继续向下传递，而是尝试交由ViewGroup消费，如果ViewGroup不消费，则事件由Activity处理。</li>
<li>当一次触摸事件决定了消费者，除非它的父节点拦截了序列中的事件，那么序列中的其他事件都会传递给这个节点，也就是说，父节点的<code>onInteruptTouchEvent</code>是唯一能够改变一次触摸事件消费者地方。</li>
</ol>
</div><div class="tags"></div><div class="post-nav"><a href="/ReactNative-Bridge的实现/" class="next">ReactNative-Bridge的实现</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Gradle/">Gradle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/">ReactNative</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作/">工作</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/插件化/">插件化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机/">计算机</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">chenlong's.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>