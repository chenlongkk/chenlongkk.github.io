<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个Android开发者的成长记录"><title>泛型与反射学习笔记 | chenlong's</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?c429fdd6ac00b6f7e59c44c7b27894b8";
var s = document.getElementsByTagName("script")[0]; 
s.parentNode.insertBefore(hm, s);
})();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">泛型与反射学习笔记</h1><a id="logo" href="/.">chenlong's</a><p class="description">Android开发技术博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 全部</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">泛型与反射学习笔记</h1><div class="post-meta">Apr 1, 2017<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="post-content"><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="一、简单泛型"><a href="#一、简单泛型" class="headerlink" title="一、简单泛型"></a>一、简单泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//泛型类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="comment">//T：类型变量</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//泛型方法</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">getData</span><span class="params">(T name)</span></span>&#123;</div><div class="line">  <span class="comment">//T:类型变量，放在修饰符和返回值之间</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//类型变量的限定</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>&gt; </span>&#123;</div><div class="line">  <span class="comment">//T:类型变量</span></div><div class="line">  <span class="comment">//Comparable &amp; Serializable:限定类型列表，列表的第一个元素为限定类型</span></div><div class="line">  </div><div class="line">&#125;</div><div class="line">在类型擦除的时候，T被替换为限定类型，如果没有限定类型，则替换为Object，上面的例子中，Pair在编译后实际上等价于：</div><div class="line"><span class="comment">//Pair&lt;T&gt;的原始类型</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">Comparable</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二、通配符类型"><a href="#二、通配符类型" class="headerlink" title="二、通配符类型"></a>二、通配符类型</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//子类限定的通配符类型</span></div><div class="line"><span class="built_in">Pair</span>&lt;? extends Employee&gt;</div><div class="line">表示任何泛型<span class="built_in">Pair</span>类型，它的类型参数是Employee的子类</div><div class="line"><span class="comment">//超类限定的通配符类型</span></div><div class="line"><span class="built_in">Pair</span>&lt;? super Manager&gt;</div><div class="line">表示任何泛型<span class="built_in">Pair</span>类型，它的类型参数是Manager的超类</div></pre></td></tr></table></figure>
<p>子类限定的通配符类型从泛型类中读取，超类限定的通配符类型向泛型类中写入</p>
<p>extends通配符和super通配符都用来确定泛型的边界，区别在于extends用来从泛型中获取数据，一般用在方法的返回值，super用来向泛型写入数据，一般用在方法的参数。</p>
<p>super，extends的作用都是确定泛型的边界，</p>
<h3 id="三、类型擦除和桥接方法"><a href="#三、类型擦除和桥接方法" class="headerlink" title="三、类型擦除和桥接方法"></a>三、类型擦除和桥接方法</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//todo</span></div></pre></td></tr></table></figure>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol>
<li><p>在泛型中创建数组</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Array</span>.<span class="keyword">new</span><span class="type">Instance</span>();</div></pre></td></tr></table></figure>
</li>
<li><p>创建泛型数组的最佳实践是创建被擦除类型的数组，然后强转。</p>
</li>
</ol>
<p>模式的存在是为了解决语言本身的限制或者缺陷</p>
<h3 id="运行时类型"><a href="#运行时类型" class="headerlink" title="运行时类型"></a>运行时类型</h3><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fgm2lgi7esj31ki14g76a.jpg" alt=""></p>
<h3 id="类和Api"><a href="#类和Api" class="headerlink" title="类和Api"></a>类和Api</h3><h4 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h4><p><code>Type</code>是Java语法中所有类型的父接口。包括：</p>
<ol>
<li>基本类型(Primitive Type)</li>
<li>数组类型(Array Type)</li>
<li>参数类型(Parameterized Type)</li>
<li>原始类型(Raw Type)</li>
<li>类型变量(Type Variable)</li>
</ol>
<p>后面三种类型都和泛型相关，参数类型代表类型<code>Collection&lt;String&gt;</code>的类型，原始类型则表示去掉类型参数之后的参数类型，例如<code>List&lt;String&gt; names = new ArrayList&lt;&gt;()</code>中，<code>List&lt;String&gt; names</code>是参数类型，<code>List rawNames</code>是原始类型。</p>
<p>TypeVariable is the common superinterface for type variables of kinds. A type variable is created the first time it is needed by a reflective method, as specified in this package. If a type variable t is referenced by a type (i.e, class, interface or annotation type) T, and T is declared by the nth enclosing class of T (see JLS 8.1.2), then the creation of t requires the resolution (see JVMS 5) of the ith enclosing class of T, for i = 0 to n, inclusive. Creating a type variable must not cause the creation of its bounds. Repeated creation of a type variable has no effect</p>
<p><code>TypeVariable</code>是所有类型的类型变量的的父接口。如果一个类型变量t 被一个类型T引用，T是由T的第n个内部类声明的，那么，创建t的时候会要求第i个内部类已经初始化，i的取值范围是0到n。创建一个类型变量<strong>一定不能</strong>触发它的边界的创建。重复创建一个类型变量没有影响。</p>
<p>究竟什么是<code>TypeVariable</code>呢？举个栗子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;T&gt; &#123;</span></div><div class="line">  T data;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;R,S&gt; <span class="function"><span class="keyword">void</span> <span class="title">map</span><span class="params">(R source ,S dest)</span></span>&#123;</div><div class="line">  <span class="comment">//</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的例子中，泛型类<code>Box</code>类中的<code>T</code>就是<code>TypeVariable</code>，泛型方法<code>map</code>中的<code>R</code>和<code>S</code>也是<code>TypeVariable</code>。</p>
<p>参数类型(Parameterized Type)和类型变量(TypeVariable)是两个不同的概念，举个栗子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(List&lt;T&gt; names)</span></span>&#123;</div><div class="line">  <span class="comment">//</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面这个泛型方法中，它的第一个参数，<code>names</code>的类型是<code>ParameterizedType</code>，而参数类型的实际类型是<code>TypeVariable</code>。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Method func1Method = Main.class.getDeclaredMethod(<span class="string">"func1"</span>,List.class);</div><div class="line"></div><div class="line">Type namesType = func1Method.getGenericParameterTypes()[<span class="number">0</span>];</div><div class="line"><span class="comment">//names instanceOf ParameterizedType</span></div><div class="line">Type typeVar = namesType.getActualTypeArguments()[<span class="number">0</span>];</div><div class="line">typeVar instanceOf TypeVariable</div></pre></td></tr></table></figure>
<p><code>Type</code>有四个子接口，分别是GenericArrayType, ParameterizedType, TypeVariable<d>, WildcardType。</d></p>
<p><strong>1. GenericArrayType</strong></p>
<blockquote>
<p>GenericArrayType represents an array type whose component type is either a parameterized type or a type variable.</p>
</blockquote>
<p>泛型数组类型(GenericArrayType)代表了元素为参数类型(ParameterizedType)或者类型变量(TypeVariable)的数组。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(T[] names)</span></span>&#123;</div><div class="line">  <span class="comment">//参数names的类型是GenericArrayType，数组元素的类型是TypeVariable。</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(Class&lt;T&gt;[] names)</span></span>&#123;</div><div class="line">  <span class="comment">//参数names的类型是GenericArrayType，数组元素的类型是ParameterizedType。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>GenericArrayType包含如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 返回数组元素的类型。</span></div><div class="line"><span class="comment"> **/</span></div><div class="line"><span class="function">Type <span class="title">getGenericComponentType</span><span class="params">()</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">例如：</span></div><div class="line"><span class="function"><span class="comment">//获取func2的method对象</span></span></div><div class="line"><span class="function">Method func2 </span>= getMethod(<span class="string">"fun2"</span>,Class[].class);</div><div class="line"><span class="comment">//获取泛型参数的类型</span></div><div class="line">Type namesType = func2.getGenericParameterTypes()[<span class="number">0</span>];</div><div class="line">GenericArrayType namesArrayType = (GenericArrayType)namesType;</div><div class="line"><span class="comment">//获取泛型数组中元素的类型，在本例中，获取的是ParameterizedType</span></div><div class="line">Type componentType = namesArrayType.getGenericComponentType();</div></pre></td></tr></table></figure>
<p><strong>2. ParameterizedType</strong></p>
<blockquote>
<p>ParameterizedType represents a parameterized type such as Collection<string>.</string></p>
</blockquote>
<p>参数类型(ParameterizedType)代表一个包含参数的类型，也就是泛型类型，例如Collection<string>。</string></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">(List&lt;String&gt; names)</span></span>&#123;</div><div class="line">  <span class="comment">//参数names的类型是ParameterizedType。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，对于泛型，如果没有写类型参数，那么就不是ParameterizedType，而是原始类型，也就是<code>Class</code>类型。例如。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">(List names)</span></span>&#123;</div><div class="line">  <span class="comment">//参数names的类型是Class。</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">(List&lt;String&gt; names)</span></span>&#123;</div><div class="line">  <span class="comment">//参数names的类型是ParameterizedType。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ParameterizedType包含如下方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 获取实际类型</span></div><div class="line"><span class="comment"> **/</span></div><div class="line">Type[] getActualTypeArguments()</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 获取原始类型，例如List&lt;String&gt;</span></div><div class="line"><span class="comment"> * 的原始类型是List</span></div><div class="line"><span class="comment"> **/</span></div><div class="line"><span class="function">Type <span class="title">getRawType</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="comment">/**</span></span></div><div class="line"><span class="function"><span class="comment"> * 如果泛型类是一个内部类，则返回包含这个类的类，否则返回null</span></span></div><div class="line"><span class="function"><span class="comment"> */</span></span></div><div class="line"><span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p>我们来看一个例子，有如下的泛型方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">func5</span><span class="params">(Map&lt;String,Number&gt; names,</span></span></div><div class="line"><span class="function"><span class="params">              Tuple&lt;? extends Number&gt; ages,</span></span></div><div class="line"><span class="function"><span class="params">              Tuple&lt;?&gt; args,</span></span></div><div class="line"><span class="function"><span class="params">              Tuple&lt;T&gt; others)</span></span>&#123;</div><div class="line">  <span class="comment">//Tuple是一个内部类。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用ParameterizedType，我们可以获取如下的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Method func5 = getMethod(<span class="string">"func5"</span>);</div><div class="line">ParameterizedType p1 = (ParameterizedType)func5.getGenericParameterTypes()[<span class="number">0</span>];</div><div class="line">ParameterizedType p2 = (ParameterizedType)func5.getGenericParameterTypes()[<span class="number">1</span>];</div><div class="line">ParameterizedType p3 = (ParameterizedType)func5.getGenericParameterTypes()[<span class="number">2</span>];</div><div class="line">ParameterizedType p4 = (ParameterizedType)func5.getGenericParameterTypes()[<span class="number">3</span>];</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//实际类型是Class,String.class和Number.class</span></div><div class="line">Type[] p1Types = p1.getActualTypeArguments();</div><div class="line"><span class="comment">//null</span></div><div class="line">Type p1OwnerType = p1.getOwnerType();</div><div class="line"><span class="comment">//Map</span></div><div class="line">Type p1RawType = p1.getRawType();</div><div class="line"><span class="comment">//////////////////////////////////////////////</span></div><div class="line"><span class="comment">//实际类型是WildcardType，? extends Number</span></div><div class="line">Type[] p2Types = p2.getActualTypeArguments();</div><div class="line"><span class="comment">//com.qiyu.study.Main</span></div><div class="line">Type p2OwnerType = p2.getOwnerType();</div><div class="line"><span class="comment">//Tuple</span></div><div class="line">Type p2RawType = p2.getRawType();</div><div class="line"><span class="comment">//////////////////////////////////////////////</span></div><div class="line"><span class="comment">//实际类型是WildcardType，?</span></div><div class="line">Type[] p3Types = p3.getActualTypeArguments();</div><div class="line"><span class="comment">//com.qiyu.study.Main</span></div><div class="line">Type p3OwnerType = p3.getOwnerType();</div><div class="line"><span class="comment">//Tuple</span></div><div class="line">Type p3RawType = p3.getRawType();</div><div class="line"><span class="comment">//////////////////////////////////////////////</span></div><div class="line"><span class="comment">//实际类型是TypeVariable，T</span></div><div class="line">Type[] p4Types = p4.getActualTypeArguments();</div><div class="line"><span class="comment">//com.qiyu.study.Main</span></div><div class="line">Type p4OwnerType = p4.getOwnerType();</div><div class="line"><span class="comment">//Tuple</span></div><div class="line">Type p4RawType = p4.getRawType();</div></pre></td></tr></table></figure>
<p><strong>3. WildcardType</strong></p>
<blockquote>
<p>WildcardType represents a wildcard type expression, such as ?, ? extends Number, or ? super Integer.</p>
</blockquote>
<p>通配符类型代表了一个通配符表达式，例如?(无界通配符)，? extends Number(上界通配符)，? super Integer(下界通配符)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func6</span><span class="params">(List&lt;? extends String&gt; p1,List&lt;? <span class="keyword">super</span> String&gt; p2，List&lt;?&gt; p3)</span></span>&#123;</div><div class="line">  <span class="comment">//&lt;? extends String&gt;:上界通配符</span></div><div class="line">  <span class="comment">//  &lt;? super String&gt;:下界通配符</span></div><div class="line">  <span class="comment">//               &lt;?&gt;:无界通配符</span></div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>WildcardType</code>包含两个方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 获取上界，如果没有指定上界，那么上界为Object</span></div><div class="line"><span class="comment"> **/</span></div><div class="line">Type[] getUpperBounds()</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 获取下界，如果没有指定下界，那么返回空数组</span></div><div class="line"><span class="comment"> **/</span></div><div class="line">Type[] getLowerBounds()</div></pre></td></tr></table></figure>
<p>关于泛型的上界、下界，可以归结为一句话。</p>
<blockquote>
<p>从上界读取，向下界写入</p>
</blockquote>
<p>看下面这个例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Food</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meat</span> <span class="keyword">extends</span> <span class="title">Food</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fgrhrwrctij30bp0b8a9x.jpg" alt=""></p>
<p>它们之间的关系如上图所示，我们以List为例，看几种常见的情况。</p>
<p>首先，我们定义了四个泛型数组和四个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;Food&gt; foodList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">ArrayList&lt;Fruit&gt; furiList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">ArrayList&lt;Meat&gt; meatList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">ArrayList&lt;Apple&gt; appleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">Food food = <span class="keyword">new</span> Food();</div><div class="line">Fruit fruit = <span class="keyword">new</span> Fruit();</div><div class="line">Meat meat = <span class="keyword">new</span> Meat();</div><div class="line">Apple apple = <span class="keyword">new</span> Apple();</div></pre></td></tr></table></figure></p>
<p>上界通配符的情况，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//上界通配符</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func6</span><span class="params">(ArrayList&lt;? extends Food&gt; foods)</span></span>&#123;</div><div class="line">  <span class="comment">//foods.add(food);</span></div><div class="line">  <span class="comment">//foods.add(fruit);</span></div><div class="line">  <span class="comment">//foods.add(meat);</span></div><div class="line">  <span class="comment">//foods.add(apple);</span></div><div class="line"></div><div class="line">  Food foodGet = foods.get(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>foods</code>的类型是一个<code>ParameterizedType</code>，它的实际类型是一个<code>WildcardType</code>，上界为<code>Food</code>，代表这个泛型接受所有<code>Food</code>的子类作为泛型参数。<br>注意，这并不意味着<code>foods</code>的类型是不确定的，它是一个确定的类型，可以理解为，所有<code>Food</code>和<code>Food</code>子类构成的泛型List的父类。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fgrnfbtmjoj30d407oq2t.jpg" alt=""></p>
<p>当然，可以这样理解，并不代表他们真的存在继承关系，其实，这也是通配符出现的最初目的，众所周知，<code>List&lt;Food&gt;</code>和<code>List&lt;Fruit&gt;</code>并没有继承关系，那么如何体现泛型参数之间的继承关系，又不破坏类型安全呢？于是就有了统配符类型，上界通配符表达的就是这样的一个关系。那么为什么，向一个上界统配符中无法写入任何类型的数据呢？已上面<code>func6</code>为例，由于<code>foods</code>是一个上界通配符类型，<code>func6</code>的实际调用参数可能是如下几种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;? extends Food&gt; foods = <span class="keyword">new</span> ArrayList&lt;Food&gt;();</div><div class="line">ArrayList&lt;? extends Food&gt; foods = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</div><div class="line">ArrayList&lt;? extends Food&gt; foods = <span class="keyword">new</span> ArrayList&lt;Meat&gt;();</div><div class="line">ArrayList&lt;? extends Food&gt; foods = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</div></pre></td></tr></table></figure></p>
<p>在无法确定实际类型的情况下，当然不能向foods中写入数据。再来看读取的时候，对于上面的四种类型，都可以向上转型成<code>Food</code>类型，因此，只需要在取数据的时候，插入强制类型转换，就可以保证类型安全，因此读取数据是可以的。</p>
<p>下界通配符的情况，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下界通配符</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func7</span><span class="params">(List&lt;? <span class="keyword">super</span> Fruit&gt; foods)</span></span>&#123;</div><div class="line">  <span class="comment">//foods.add(food);</span></div><div class="line">  <span class="comment">//foods.add(meat);</span></div><div class="line">  foods.add(fruit);</div><div class="line">  foods.add(apple);</div><div class="line"></div><div class="line">  Object foodGet = foods.get(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理，<code>foods</code>代表所有<code>Fruit</code>和<code>Fruit</code>的父类组成的泛型List，可以是如下几种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;? extends Fruit&gt; foods = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</div><div class="line">ArrayList&lt;? extends Fruit&gt; foods = <span class="keyword">new</span> ArrayList&lt;Food&gt;();</div><div class="line">ArrayList&lt;? extends Fruit&gt; foods = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</div></pre></td></tr></table></figure>
<p>那么，向这个List中可以写入的’最大’的类型是<code>Fruit</code>，取出的时候，由于不知道<code>foods</code>的实际类型，因此只能取出<code>Object</code></p>
<p><strong>4. TypeVariable</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 获取声明泛型的对象，可以是Class或者Excutable，即Constructor和Method</span></div><div class="line"><span class="comment"> **/</span></div><div class="line">getGenericDeclaration()</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 获取泛型边界</span></div><div class="line"><span class="comment"> **/</span></div><div class="line">Type[] getBounds();</div></pre></td></tr></table></figure>
<p>我们简单的看两个例子，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T extends Meat&amp;ICanEat&gt; <span class="function"><span class="keyword">void</span> <span class="title">func8</span><span class="params">(Tuple&lt;? extends T&gt; p2,T p)</span></span>&#123;</div><div class="line">  <span class="comment">//Tuple是一个内部类</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们首先要明确这个方法声明里，哪里才是<code>TypeVariable</code>。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fgrptjtsbzj30wu03a751.jpg" alt=""></p>
<p>对于func8，有三个地方可以获取它的TypeVariable。</p>
<p>第一个地方：</p>
<p>对于一个方法对象<code>Method</code>，它首先实现了<code>GenericDeclaration</code>，这意味着它是可以声明类型参数的。对于<code>func8</code>来说，它的<code>getTypeParameters</code>方法，返回了图示的1部分，也就是<code>func8</code>声明的泛型参数<code>T</code>。我们找到第一个获取TypeVariable的地方。</p>
<p>第二个地方：</p>
<p>对于一个方法对象，它继承了<code>Executable</code>，这意味它可以包含调用参数。<code>func8</code>的<code>getGenericParameterTypes</code>方法返回了图示2和4的部分，结合上面的分析，我们知道，2的类型是<code>ParameterizedType</code>,4的类型是<code>TypeVariable</code>，此处是第二个获取TypeVariable的地方。</p>
<p>第三个地方：</p>
<p>上面提到，<code>func8</code>的第一个参数的类型是<code>ParameterizedType</code>，那么它还有一个实际的参数类型，结合上面的分析，我们知道，实际类型是一个<code>WildcardType</code>，由于是一个上界通配符类型，因此我们获取它的上界，此时获取的就是<code>T</code>，此处是第三个获取<code>TypeVariable</code>的地方。</p>
<p>此时，我们产生了一个问题，那就是从这个三个地方获取的<code>TypeVariable</code>是同一个实例吗？我们尝试一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Method func7 = TypeVariableTest.class.getDeclaredMethod(<span class="string">"tfunc7"</span>,Tuple.class,Meat.class);</div><div class="line"></div><div class="line"><span class="comment">//获取图示1的TypeVariable</span></div><div class="line">TypeVariable t_01 = func7.getTypeParameters()[<span class="number">0</span>];</div><div class="line"></div><div class="line"><span class="comment">//获取图示3的TypeVariable</span></div><div class="line">TypeVariable t_02 = (TypeVariable)((WildcardType)((ParameterizedType)func7.getGenericParameterTypes()[<span class="number">0</span>]).getActualTypeArguments()[<span class="number">0</span>]).getUpperBounds()[<span class="number">0</span>];</div><div class="line"></div><div class="line"><span class="comment">//获取图示4的TypeVariable</span></div><div class="line">TypeVariable t_03 = (TypeVariable) func7.getGenericParameterTypes()[<span class="number">1</span>];</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span>(t_01 == t_02 &amp;&amp; t_02 == t_03)&#123;</div><div class="line">  print(<span class="string">"same instance"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//实际的结果是，他们的确是同一个实例。</span></div></pre></td></tr></table></figure>
<p>然后，我们来看看，TypeVariable的两个重要方法。</p>
<p>getBounds</p>
<p>获取泛型的边界，通常来说，我们使用extends关键字声明边界的时候，只会声明一个，例如<code>List&lt;T extends Meat&gt;</code>,这意味着，在进行类型擦除的时候，所有的T会使用Fruit来替换，并且在适当的地方会插入<code>(Meat)</code>的强制类型转换。但是，有的时候，我们也会声明多个泛型边界，使用<code>&amp;</code>连接，例如<code>List&lt;T extends Fruit&amp;ICanEat&gt;</code>。除了第一个边界可以是类以外，其他的边界一定是接口，在类型擦除的时候也只会擦除到第一个边界。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">printTypeArrays(t_01.getBounds());</div><div class="line"><span class="comment">//输出为：</span></div><div class="line"><span class="comment">//Meat</span></div><div class="line"><span class="comment">//ICanEat</span></div></pre></td></tr></table></figure>
<p>getGenericDeclaration</p>
<p>获取声明泛型的对象实例，可以声明泛型的对象有Class，Method，Constructor。在本例中，我们获取的是Method对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print(t_01.getGenericDeclaration().getClass());</div><div class="line"><span class="comment">//输出为：</span></div><div class="line"><span class="comment">//class java.lang.reflect.Method</span></div></pre></td></tr></table></figure>
<h4 id="AnnotatedElement"><a href="#AnnotatedElement" class="headerlink" title="AnnotatedElement"></a>AnnotatedElement</h4><blockquote>
<p>Represents an annotated element of the program currently running in this VM. This interface allows annotations to be read reflectively. All annotations returned by methods in this interface are immutable and serializable. The arrays returned by methods of this interface may be modified by callers without affecting the arrays returned to other callers.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 获取直接声明的注解</span></div><div class="line"><span class="comment"> **/</span></div><div class="line">Annotation[] getDeclaredAnnotations()</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 获取所有的注解，包括继承来的注解</span></div><div class="line"><span class="comment"> **/</span></div><div class="line">Annotation[] getAnnotations()</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 根据注解的类型，获取注解</span></div><div class="line"><span class="comment"> **/</span></div><div class="line">&lt;T extends Annotation&gt; <span class="function">T <span class="title">getAnnotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">/**</span></span></div><div class="line"><span class="function"><span class="comment"> * 指定类型的注解是否存在，包括继承来的注解</span></span></div><div class="line"><span class="function"><span class="comment"> **/</span></span></div><div class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span></span></div></pre></td></tr></table></figure>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAssignableFrom</span><span class="params">(Class&lt;?&gt; cls)</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterface</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isArray</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isPrimitive</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnnotation</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSynthetic</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnonymousClass</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocalClass</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMemberClass</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="keyword">public</span> TypeVariable&lt;Class&lt;T&gt;&gt;[] <span class="title">getTypeParameters</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;? <span class="keyword">super</span> T&gt; <span class="title">getSuperclass</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> Type <span class="title">getGenericSuperclass</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> Package <span class="title">getPackage</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> Class&lt;?&gt;[] <span class="title">getInterfaces</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> Type[] <span class="title">getGenericInterfaces</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; <span class="title">getComponentType</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getEnclosingMethod</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;?&gt; <span class="title">getEnclosingConstructor</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
<p>总的来说，搞清楚Type的几个子接口，基本上就明白了运行时的类型系统，java8新增的AnnotatedType等有空再研究，反正一时半会儿也用不上。</p>
</div><div class="tags"></div><div class="post-nav"><a href="/Retrofit源码阅读/" class="pre">Retrofit源码阅读</a><a href="/AndroidGradlePlugin源码阅读-导入源码/" class="next">AndroidGradlePlugin源码阅读-导入源码</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Gradle/">Gradle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/">ReactNative</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作/">工作</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/插件化/">插件化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机/">计算机</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">chenlong's.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>