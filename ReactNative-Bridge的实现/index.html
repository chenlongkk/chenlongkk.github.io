<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个Android开发者的成长记录"><title>ReactNative-Bridge的实现 | chenlong's</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?c429fdd6ac00b6f7e59c44c7b27894b8";
var s = document.getElementsByTagName("script")[0]; 
s.parentNode.insertBefore(hm, s);
})();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ReactNative-Bridge的实现</h1><a id="logo" href="/.">chenlong's</a><p class="description">Android开发技术博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 全部</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ReactNative-Bridge的实现</h1><div class="post-meta">Aug 17, 2017<span> | </span><span class="category"><a href="/categories/ReactNative/">ReactNative</a></span></div><div class="post-content"><h2 id="ReactNative-Bridge在Android平台的实现"><a href="#ReactNative-Bridge在Android平台的实现" class="headerlink" title="ReactNative Bridge在Android平台的实现"></a>ReactNative Bridge在Android平台的实现</h2><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><h4 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h4><p>基于Handler实现的标准的MessageQueue，在Bridge中存在以下几个MessageQueue：</p>
<ol>
<li>NativeModulesQueue，异步线程，用于执行NativeModule的代码。</li>
<li>JSModuleQueue，异步线程，用于执行js的代码</li>
<li>UIBackgroundQueue，异步线程，用于在异步线程进行UI操作，默认没有启用。</li>
<li>UIThreadQueue，主线程，默认情况，UI操作在这个线程执行。</li>
</ol>
<h4 id="NativeModule和JSModule"><a href="#NativeModule和JSModule" class="headerlink" title="NativeModule和JSModule"></a>NativeModule和JSModule</h4><p>所有需要暴露给js调用的java代码需要实现NativeModule接口，每一个暴露给JS的方法需要加上<code>@ReactMethod</code>注解具体的实现方式可以参考文档。</p>
<p>从原生代码调用js函数文档中没有具体介绍，但是参考官方的实现可以发现所有的jsModule都是一个继承自JavaScriptModule的接口，在Bridge初始化时会创建这些接口的动态代理，将方法调用转发到js执行引擎中。</p>
<p>ReactNative提供了统一的入口用来注册NativeModule和JSModule，通过创建ReactPackage的实例，我们可以一次性将所有的NativeModule，jsModule注册到Bridge。</p>
<h3 id="二、UML"><a href="#二、UML" class="headerlink" title="二、UML"></a>二、UML</h3><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fj1u0cg0t2j31kw0s5tfx.jpg" alt=""></p>
<h3 id="三、Bridge的初始化"><a href="#三、Bridge的初始化" class="headerlink" title="三、Bridge的初始化"></a>三、Bridge的初始化</h3><p>Bridge的初始化的入口在Java层的CatalystInstanceImpl的构造方法中，实现代码基本上在C++中，我们从Java层的CatalystInstanceImpl开始。</p>
<h4 id="Step-1-创建Instance实例"><a href="#Step-1-创建Instance实例" class="headerlink" title="Step 1 创建Instance实例"></a>Step 1 创建Instance实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//Java层的CatalystInstanceImpl在C++有对应的实现，创建CatalystInstanceImpl实例的同时会在C++层创建Instance的实例。</span></div><div class="line"><span class="comment">//ReactNative的代码中对于这种需要在C++和Java同时访问的对象封装了统一的实现，HybridData，目的是为了在Java层能够执行C++层的析构方法。</span></div><div class="line">mHybridData = initHybrid();</div><div class="line"></div><div class="line"><span class="comment">//创建MessageQueue</span></div><div class="line">mReactQueueConfiguration = ReactQueueConfigurationImpl.create(</div><div class="line">      reactQueueConfigurationSpec,</div><div class="line">      <span class="keyword">new</span> NativeExceptionHandler());</div><div class="line"><span class="comment">//原生模块</span></div><div class="line">mJavaRegistry = registry;</div><div class="line"><span class="comment">//js模块</span></div><div class="line">mJSModuleRegistry = jsModuleRegistry;</div><div class="line"></div><div class="line"><span class="comment">//原生模块执行线程</span></div><div class="line">mNativeModulesQueueThread = mReactQueueConfiguration.getNativeModulesQueueThread();</div><div class="line"><span class="comment">//异步UI线程</span></div><div class="line">mUIBackgroundQueueThread = mReactQueueConfiguration.getUIBackgroundQueueThread();</div><div class="line">  </div><div class="line"><span class="comment">//初始化Bridge</span></div><div class="line">initializeBridge(</div><div class="line">    <span class="comment">//执行js的前后会回调这个方法</span></div><div class="line">    <span class="keyword">new</span> BridgeCallback(<span class="keyword">this</span>),</div><div class="line">    <span class="comment">//此处并没有创建JS执行引擎，这里只是一个holder，实际的创建是在C++层</span></div><div class="line">    jsExecutor,</div><div class="line">    <span class="comment">//js执行线程</span></div><div class="line">    mReactQueueConfiguration.getJSQueueThread(),</div><div class="line">    <span class="comment">//原生模块执行线程</span></div><div class="line">    mNativeModulesQueueThread,</div><div class="line">    <span class="comment">//异步UI线程</span></div><div class="line">    mUIBackgroundQueueThread,</div><div class="line">    <span class="comment">//获取所有的java实现的原生模块，这里返回的是JavaModuleWrapper</span></div><div class="line">    mJavaRegistry.getJavaModules(<span class="keyword">this</span>),</div><div class="line">    <span class="comment">//获取所有c++实现的原生模块</span></div><div class="line">    mJavaRegistry.getCxxModules());</div></pre></td></tr></table></figure>
<h4 id="Step-2-在C-层执行initializeBridge"><a href="#Step-2-在C-层执行initializeBridge" class="headerlink" title="Step 2 在C++层执行initializeBridge"></a>Step 2 在C++层执行initializeBridge</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JMessageQueueThread是MessageQueue在C++层的实现，只是对Java层传入的MessageQueue实例进行了包装，</span></div><div class="line"><span class="comment">//实际的执行逻辑通过JNI返回到java层中执行</span></div><div class="line">moduleMessageQueue_ = <span class="built_in">std</span>::make_shared&lt;JMessageQueueThread&gt;(nativeModulesQueue);</div><div class="line"><span class="keyword">if</span> (uiBackgroundQueue.get() != <span class="literal">nullptr</span>) &#123;</div><div class="line">    uiBackgroundMessageQueue_ = <span class="built_in">std</span>::make_shared&lt;JMessageQueueThread&gt;(uiBackgroundQueue);</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用Instance的初始化方法，进行初始化。</span></div><div class="line"><span class="comment">//CatalystInstanceImpl存在的意义只是持有Instance的实例，所有的逻辑都会转发到Instance实现</span></div><div class="line"><span class="comment">//Instance则是ReactNative管理Bridge的跨平台实现的核心</span></div><div class="line">instance_-&gt;initializeBridge(</div><div class="line">    <span class="comment">//创建Callback的wrapper，和JMessageQueue的实现原理一样</span></div><div class="line">    folly::make_unique&lt;JInstanceCallback&gt;(</div><div class="line">    callback,</div><div class="line">    uiBackgroundMessageQueue_ != <span class="literal">NULL</span> ? uiBackgroundMessageQueue_ : moduleMessageQueue_),</div><div class="line"></div><div class="line">    <span class="comment">//js执行引擎的工厂</span></div><div class="line">    jseh-&gt;getExecutorFactory(),</div><div class="line"></div><div class="line">    <span class="comment">//jsQueue的Wrapper</span></div><div class="line">    folly::make_unique&lt;JMessageQueueThread&gt;(jsQueue),</div><div class="line"></div><div class="line">    <span class="comment">//创建ModuleRegistry</span></div><div class="line">    <span class="comment">//1. 对每一个java层传入的JavaModules,创建一个C++的JavaNativeModule包装类</span></div><div class="line">    <span class="comment">//2. 创建ModuleRegistry,包含了所有的JavaModules和CXXModules</span></div><div class="line">    <span class="comment">//java层传入的JavaModuleWrapper会在此处包装成一个JavaNativeModule的实例</span></div><div class="line">    <span class="comment">//JavaNativeModule包含Instance实例的引用，Java层传入JavaModuleWrapper实例，以及原生模块的执行线程队列。</span></div><div class="line">    <span class="comment">//非常有趣的是，如果启用了UIBackgroundThread，那么，UIManager、NativeAnimatedModule、FBFacebookReactNavigator</span></div><div class="line">    <span class="comment">//三个原生模块的执行线程队列会是UIBackgroundThread，即使是Facebook也躲不开hardcode...</span></div><div class="line">    buildModuleRegistry(</div><div class="line">      <span class="built_in">std</span>::weak_ptr&lt;Instance&gt;(instance_),</div><div class="line">      javaModules,</div><div class="line">      cxxModules,</div><div class="line">      moduleMessageQueue_,</div><div class="line">      uiBackgroundMessageQueue_)</div><div class="line">  );</div></pre></td></tr></table></figure>
<h4 id="Step-4-Instance执行initializeBridge方法"><a href="#Step-4-Instance执行initializeBridge方法" class="headerlink" title="Step 4 Instance执行initializeBridge方法"></a>Step 4 Instance执行initializeBridge方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//赋值JInstanceCallback</span></div><div class="line">callback_ = <span class="built_in">std</span>::move(callback);</div><div class="line"><span class="comment">//同步执行一个runnable，创建NativeToJsBridge</span></div><div class="line"><span class="comment">//这里执行过程比较绕，首先需要把这个lambda表达式包装一层lambda表达式，catch内部的异常</span></div><div class="line"><span class="comment">//然后创建一个JNativeRunnable对象传入刚刚包装的lambda，接着在java层的队列中执行这个JNativeRunnable</span></div><div class="line"><span class="comment">//JNativeRunable的run方法会回到C++层，执行内部的lambda</span></div><div class="line">jsQueue-&gt;runOnQueueSync(</div><div class="line">    <span class="comment">//lambda表达式</span></div><div class="line">    [<span class="keyword">this</span>, &amp;jsef, moduleRegistry, jsQueue] () <span class="keyword">mutable</span> &#123;</div><div class="line">      <span class="comment">//创建NativeToJsBridge</span></div><div class="line">      nativeToJsBridge_ = folly::make_unique&lt;NativeToJsBridge&gt;(</div><div class="line">          jsef.get(),     <span class="comment">//JSC工厂</span></div><div class="line">          moduleRegistry, <span class="comment">//原生模块</span></div><div class="line">          jsQueue,        <span class="comment">//js执行队列</span></div><div class="line">          callback_       <span class="comment">//回调</span></div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  );</div></pre></td></tr></table></figure>
<h4 id="Step-5-创建NativeToJsBridge对象"><a href="#Step-5-创建NativeToJsBridge对象" class="headerlink" title="Step 5 创建NativeToJsBridge对象"></a>Step 5 创建NativeToJsBridge对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NativeToJsBridge::NativeToJsBridge(</div><div class="line">    JSExecutorFactory* jsExecutorFactory,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ModuleRegistry&gt; registry,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MessageQueueThread&gt; jsQueue,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;InstanceCallback&gt; callback)</div><div class="line">    : m_destroyed(<span class="built_in">std</span>::make_shared&lt;<span class="keyword">bool</span>&gt;(<span class="literal">false</span>))</div><div class="line">      <span class="comment">//创建JsToNativeBridge</span></div><div class="line">    , m_delegate(<span class="built_in">std</span>::make_shared&lt;JsToNativeBridge&gt;(registry, callback))</div><div class="line">      <span class="comment">//初始化JSC vm</span></div><div class="line">      <span class="comment">//在js的global对象上注册了两个方法</span></div><div class="line">      <span class="comment">//1. nativeFlushQueueImmediate</span></div><div class="line">      <span class="comment">//2. nativeCallSyncHook</span></div><div class="line">    , m_executor(jsExecutorFactory-&gt;createJSExecutor(m_delegate, jsQueue))</div><div class="line">    , m_executorMessageQueueThread(<span class="built_in">std</span>::move(jsQueue)) &#123;&#125;</div></pre></td></tr></table></figure>
<p>首选创建JsToNativeBridge实例，接受两个参数，ModuleRegistry和InstanceCallback，这个对象的将负责js调用原生代码的逻辑。</p>
<p>接着是创建NativeToJsBridge的核心，即创建并初始化JavaScriptCore实例，具体过程如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建全局对象的class</span></div><div class="line">JSClassRef globalClass = <span class="literal">nullptr</span>;</div><div class="line"><span class="comment">//定义一个js类的结构体，可以用来配置这个类的名称，父类，静态值，静态方法等...</span></div><div class="line"><span class="comment">//这应该指的是es6的class吧？涉及到js的class的实现，有点懵。</span></div><div class="line">JSClassDefinition definition = kJSClassDefinitionEmpty;</div><div class="line">definition.attributes |= kJSClassAttributeNoAutomaticPrototype;</div><div class="line"><span class="comment">//调用JSC的JSClassCreate函数</span></div><div class="line">globalClass = JSC_JSClassCreate(useCustomJSC, &amp;definition);</div><div class="line"><span class="comment">//调用JSC的JSGlobalContextCreateInGroup函数，创建并返回一个包含global对象的js执行上下文</span></div><div class="line">m_context = JSC_JSGlobalContextCreateInGroup(useCustomJSC, <span class="literal">nullptr</span>, globalClass);</div><div class="line"><span class="comment">//将c++的nativeFlushQueueImmediate函数绑定到js的global对象上</span></div><div class="line">installNativeHook&lt;&amp;JSCExecutor::nativeFlushQueueImmediate&gt;(<span class="string">"nativeFlushQueueImmediate"</span>);</div><div class="line"><span class="comment">//同上</span></div><div class="line">installNativeHook&lt;&amp;JSCExecutor::nativeCallSyncHook&gt;(<span class="string">"nativeCallSyncHook"</span>);</div><div class="line"><span class="comment">//在global对象上设置一个nativeModuleProxy属性，这个属性的值是空的js对象，</span></div><div class="line"><span class="comment">//但是这个js对象的getProperty方法是一个c++的方法，getNativeModule。</span></div><div class="line"><span class="comment">//在js中，我们通常会这样获取原生模块：</span></div><div class="line"><span class="comment">//import &#123; NativeModules &#125; from 'react-native';</span></div><div class="line"><span class="comment">//NativeModules.ToastModule.showToast('toast');</span></div><div class="line"><span class="comment">//import的NativeModules也就是我们绑定到global对象上的nativeModuleProxy对象，</span></div><div class="line"><span class="comment">//NativeModules.ToastModules即是在nativeModuleProxy获取名为ToastModules的属性，这会走到</span></div><div class="line"><span class="comment">//nativeModuleProxy的getProperty方法上，进而进入我们刚刚绑定的JSCExecutor::getNativeModule函数</span></div><div class="line">installGlobalProxy(m_context,</div><div class="line">                   <span class="string">"nativeModuleProxy"</span>,</div><div class="line">                   exceptionWrapMethod&lt;&amp;JSCExecutor::getNativeModule&gt;());</div></pre></td></tr></table></figure>
<h4 id="Step-6-Js对Bridge的初始化"><a href="#Step-6-Js对Bridge的初始化" class="headerlink" title="Step 6 Js对Bridge的初始化"></a>Step 6 Js对Bridge的初始化</h4><p>上面5步中完成了原生代码对Bridge的初始化，接下来会加载打包后的bundle文件。ReactNative支持三种模式的Bundle文件。</p>
<ol>
<li>String类型: 在android平台上支持从assets和文件读取bundle文件，一次性读取文件内容到内存，展开成utf8的字符串。</li>
<li>UnBundle类型: 这种类型在android和ios上的实现不一样，在android上会对每一个模块打包成一个js文件，在ios上则是将各个模块的js文件合并成一个二进制文件，通过偏移量来读取模块。</li>
<li>BcBundle类型: 看名称的定义应该是加载某种字节码文件，但是在react native的打包工具中没有参数支持打包出这种类型的bundle。</li>
</ol>
<p>我们假定使用的是最简单的String类型，在java层调用CatalystInstanceImpl的jniLoadScriptFromFile会从文件中读取jsbundle文件，bundle文件的内容即是一份压缩后的js代码，它的具体内容会在后面介绍。</p>
<p>经过一些列的跳转之后，最终加载bundle文件的地方在JSCExecutor中，我们简单看一下它的流程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 加载bundle文件</span></div><div class="line"><span class="comment"> * @param script  读入的bundle文件内容</span></div><div class="line"><span class="comment"> * @sourceURL     debug时使用的packager server地址</span></div><div class="line"><span class="comment"> **/</span></div><div class="line"><span class="keyword">void</span> JSCExecutor::loadApplicationScript(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">const</span> JSBigString&gt; script, <span class="built_in">std</span>::<span class="built_in">string</span> sourceURL) &#123;</div><div class="line">  ...</div><div class="line">  <span class="comment">//省略了bundle类型的判断等无关代码</span></div><div class="line">  ...</div><div class="line">  <span class="comment">//调用JSC的JSEvaluateScript函数，执行js bundle</span></div><div class="line">  evaluateScript(m_context, jsScript, jsSourceURL);</div><div class="line">  <span class="comment">//调用js的方法，清空js的MessageQueue</span></div><div class="line">  flush();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>flush函数调用了我们刚刚执行的js bundle中的方法，具体的过程如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//m_flushedQueueJS是一个js中的方法，如果已经缓存过这个方法，</span></div><div class="line"><span class="comment">//则执行它，它的返回值是一个数组，如果在evaluateScript的过程</span></div><div class="line"><span class="comment">//js侧有调用过Native的代码，那么数组会包含相应的调用信息，至于它</span></div><div class="line"><span class="comment">//的具体内容是怎样的，会在后面介绍。</span></div><div class="line"><span class="keyword">if</span> (m_flushedQueueJS) &#123;</div><div class="line">  callNativeModules(m_flushedQueueJS-&gt;callAsFunction(&#123;&#125;));</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//如果没有缓存过m_flushedQueueJS方法，那么先缓存</span></div><div class="line"><span class="comment">//获取global对象上的__fbBatchedBridge对象</span></div><div class="line"><span class="keyword">auto</span> global = Object::getGlobalObject(m_context);</div><div class="line"><span class="keyword">auto</span> batchedBridgeValue = global.getProperty(<span class="string">"__fbBatchedBridge"</span>);</div><div class="line"><span class="keyword">if</span> (!batchedBridgeValue.isUndefined()) &#123;</div><div class="line">  <span class="comment">//bindBridge的具体过程</span></div><div class="line">  <span class="comment">//获取__fbBatchedBridge的值</span></div><div class="line">  <span class="comment">//auto batchedBridge = batchedBridgeValue.asObject();</span></div><div class="line">  <span class="comment">//缓存js方法</span></div><div class="line">  <span class="comment">//m_callFunctionReturnFlushedQueueJS = batchedBridge.getProperty("callFunctionReturnFlushedQueue").asObject();</span></div><div class="line">  <span class="comment">//m_invokeCallbackAndReturnFlushedQueueJS = batchedBridge.getProperty("invokeCallbackAndReturnFlushedQueue").asObject();</span></div><div class="line">  <span class="comment">//m_flushedQueueJS = batchedBridge.getProperty("flushedQueue").asObject();</span></div><div class="line">  <span class="comment">//m_callFunctionReturnResultAndFlushedQueueJS = batchedBridge.getProperty("callFunctionReturnResultAndFlushedQueue").asObject();</span></div><div class="line">  <span class="comment">//在这里，我们缓存了四个js上的方法：</span></div><div class="line">  <span class="comment">//1. callFunctionReturnFlushedQueue           //调用js方法并立刻返回</span></div><div class="line">  <span class="comment">//2. invokeCallbackAndReturnFlushedQueue      //调用js的callback，并立刻返回</span></div><div class="line">  <span class="comment">//3. flushedQueue                             //立刻触发js对原生的调用</span></div><div class="line">  <span class="comment">//4. callFunctionReturnResultAndFlushedQueue  //调用js方法并返回结果</span></div><div class="line">  bindBridge();</div><div class="line">  callNativeModules(m_flushedQueueJS-&gt;callAsFunction(&#123;&#125;));</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_delegate) &#123;</div><div class="line">  callNativeModules(Value::makeNull(m_context));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，我们完成了Bridge的初始化，虽然细分出了六个步骤，但是Bridge的核心其实很简单，可以分为三步。</p>
<p>第一步，创建并初始化JavaScriptCore的实例</p>
<p>第二步，在js的global对象上绑定两个方法nativeFlushQueueImmediate，nativeCallSyncHook，以及一个对象nativeModuleProxy。绑定的两个方法作为js调用native的入口，nativeModuleProxy则充当了Native模块路由的功能，js侧通过这个对象获取原生模块。</p>
<p>第三步，缓存js中的四个方法，callFunctionReturnFlushedQueue，invokeCallbackAndReturnFlushedQueue，flushedQueue，callFunctionReturnResultAndFlushedQueue。这个四个方法将作为native侧调用js方法的入口。</p>
<h3 id="四、Native调用JS方法"><a href="#四、Native调用JS方法" class="headerlink" title="四、Native调用JS方法"></a>四、Native调用JS方法</h3><p>我们看一个例子，也就是ReactRootView启动app的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">runApplication</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">//...省略不重要的代码</span></div><div class="line">  CatalystInstance instance = reactContext.getCatalystInstance();</div><div class="line">  instance.getJSModule(AppRegistry.class).runApplication(jsAppModuleName, appParams);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Bridge初始化的时候，我们默认注册了CorePackage和MainPackage中的native/js模块，我们看看AppRegistry定义了哪些方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppRegistry</span> <span class="keyword">extends</span> <span class="title">JavaScriptModule</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">runApplication</span><span class="params">(String appKey, WritableMap appParameters)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unmountApplicationComponentAtRootTag</span><span class="params">(<span class="keyword">int</span> rootNodeTag)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">startHeadlessTask</span><span class="params">(<span class="keyword">int</span> taskId, String taskKey, WritableMap data)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继续看CatalystInstance的getJSModule方法会调用JavaScriptModuleRegistry的getJavaScriptModule方法获取AppRegistry的动态代理实例，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T extends JavaScriptModule&gt; <span class="function">T <span class="title">getJavaScriptModule</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">      CatalystInstance instance,</span></span></div><div class="line"><span class="function"><span class="params">      Class&lt;T&gt; moduleInterface)</span> </span>&#123;</div><div class="line">    <span class="comment">//如果已经缓存过，直接返回</span></div><div class="line">    JavaScriptModule <span class="keyword">module</span> = mModuleInstances.get(moduleInterface);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> (T) <span class="keyword">module</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//获取AppRegistry的包装类JavaScriptModuleRegistration</span></div><div class="line">    JavaScriptModuleRegistration registration = mModuleRegistrations.get(moduleInterface)</div><div class="line">    <span class="comment">//创建动态代理，缓存后返回。</span></div><div class="line">    JavaScriptModule interfaceProxy = (JavaScriptModule) Proxy.newProxyInstance(</div><div class="line">        moduleInterface.getClassLoader(),</div><div class="line">        <span class="keyword">new</span> Class[]&#123;moduleInterface&#125;,</div><div class="line">        <span class="keyword">new</span> JavaScriptModuleInvocationHandler(instance, registration));</div><div class="line">    mModuleInstances.put(moduleInterface, interfaceProxy);</div><div class="line">    <span class="keyword">return</span> (T) interfaceProxy;</div><div class="line">&#125;</div><div class="line"><span class="comment">//代理方法执行，大概是动态代理的标准用法了，我们在Retrofit里也见过一样的用法。</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaScriptModuleInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="comment">//...省略构造方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">      NativeArray jsArgs = args != <span class="keyword">null</span> ? Arguments.fromJavaArgs(args) : <span class="keyword">new</span> WritableNativeArray();</div><div class="line">      mCatalystInstance.callFunction(</div><div class="line">        mModuleRegistration.getName(),</div><div class="line">        method.getName(),</div><div class="line">        jsArgs</div><div class="line">      );</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代理执行的逻辑上看，创建一个JSModule的目的只是为了java层更方便的调用js方法，实际的参数依然只是需要方法名和参数就可以了。CatalystInstanceImpl的callFunction方法经过一系列的校验之后，进入C++中，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//Instance</span></div><div class="line"><span class="keyword">void</span> Instance::callJSFunction(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; <span class="keyword">module</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; method, folly::dynamic&amp;&amp; params) &#123;</div><div class="line">  <span class="comment">//调用java层的callback，增加一次call的计数，看实现的话，主要是为了debug和trace</span></div><div class="line">  callback_-&gt;incrementPendingJSCalls();</div><div class="line">  nativeToJsBridge_-&gt;callFunction(<span class="built_in">std</span>::move(<span class="keyword">module</span>), <span class="built_in">std</span>::move(method), <span class="built_in">std</span>::move(params));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//NativeToJsBridge</span></div><div class="line"><span class="keyword">void</span> NativeToJsBridge::callFunction(</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; <span class="keyword">module</span>,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; method,</div><div class="line">    folly::dynamic&amp;&amp; arguments) &#123;</div><div class="line">  <span class="comment">//在js的执行队列中执行js的调用</span></div><div class="line">  runOnExecutorQueue([<span class="keyword">module</span> = <span class="built_in">std</span>::move(<span class="keyword">module</span>), method = <span class="built_in">std</span>::move(method), arguments = <span class="built_in">std</span>::move(arguments), systraceCookie]</div><div class="line">    (JSExecutor* executor) &#123;</div><div class="line">      executor-&gt;callFunction(<span class="keyword">module</span>, method, arguments);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在Bridge里进行一次跳转，进入JSCExecutor</span></div><div class="line"><span class="keyword">void</span> JSCExecutor::callFunction(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; moduleId,       <span class="comment">// js模块名称</span></div><div class="line">                               <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; methodId,       <span class="comment">// js方法名称</span></div><div class="line">                               <span class="keyword">const</span> folly::dynamic&amp; arguments)&#123;  <span class="comment">// 参数</span></div><div class="line">    <span class="comment">//原始代码是一个立即执行的lambda函数，翻译了一下，只保留重点部分</span></div><div class="line">    </div><div class="line">    <span class="comment">//如果没有绑定过Bridge，先绑定。在Bridge初始化的时候，已经绑定过</span></div><div class="line">    <span class="keyword">if</span> (!m_callFunctionReturnResultAndFlushedQueueJS) &#123;</div><div class="line">        bindBridge();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//执行js的callFunctionReturnFlushedQueueJS方法</span></div><div class="line">    <span class="keyword">auto</span> result = m_callFunctionReturnFlushedQueueJS-&gt;callAsFunction(&#123;</div><div class="line">        Value(m_context, String::createExpectingAscii(m_context, moduleId)),<span class="comment">//js模块名称</span></div><div class="line">        Value(m_context, String::createExpectingAscii(m_context, methodId)),<span class="comment">//js方法名称</span></div><div class="line">        Value::fromDynamic(m_context, <span class="built_in">std</span>::move(arguments))                 <span class="comment">//参数</span></div><div class="line">      &#125;);</div><div class="line">    <span class="comment">//调用结束后，执行js对原生的调用</span></div><div class="line">    callNativeModules(<span class="built_in">std</span>::move(result));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这之后就进入js的逻辑了，在看具体的实现之前，我们先熟悉一下ReactNative在js部分代码结构。</p>
<p>大致分为以下几个部分，react框架，polyfill，BatchedBridge，原生和js的桥接代码。其中BatchedBridge就是js和Native通信的核心，包含两个对象，MessageQueue.js和NativeModules.js。MessageQueue用来维持js调用Native的队列，NativeModules充当了原生模块路由的作用，用来寻找原生模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MeesageQueue</span></div><div class="line"><span class="comment">//Native调用js的入口，绑定在C++上</span></div><div class="line">callFunctionReturnFlushedQueue(<span class="built_in">module</span>: string, <span class="attr">method</span>: string, <span class="attr">args</span>: <span class="built_in">Array</span>&lt;any&gt;) &#123;</div><div class="line">    <span class="comment">//执行方法</span></div><div class="line">    <span class="keyword">this</span>.__callFunction(<span class="built_in">module</span>, method, args);</div><div class="line">    <span class="comment">//返回当前的queue，如果没有任何js对原生的调用，则返回空的queue</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.flushedQueue();</div><div class="line">&#125;</div><div class="line"></div><div class="line">flushedQueue() &#123;</div><div class="line">    <span class="keyword">this</span>.__callImmediates();</div><div class="line">    <span class="keyword">const</span> queue = <span class="keyword">this</span>._queue;</div><div class="line">    <span class="keyword">this</span>._queue = [[], [], [], <span class="keyword">this</span>._callID];</div><div class="line">    <span class="keyword">return</span> queue[<span class="number">0</span>].length ? queue : <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//执行js方法</span></div><div class="line">__callFunction(<span class="built_in">module</span>: string, <span class="attr">method</span>: string, <span class="attr">args</span>: <span class="built_in">Array</span>&lt;any&gt;) &#123;</div><div class="line">    <span class="comment">//获取指定js模块的所有方法</span></div><div class="line">    <span class="keyword">const</span> moduleMethods = <span class="keyword">this</span>._getCallableModule(<span class="built_in">module</span>);</div><div class="line">    <span class="comment">//执行指定的方法</span></div><div class="line">    <span class="keyword">const</span> result = moduleMethods[method].apply(moduleMethods, args);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的过程里，我们有两个疑惑，首先我们如何获取指定的js模块？其次，js返回的queue是怎么样的？</p>
<p>先回答第一个问题，如何获取指定的js模块，很简单，依靠js模块向Bridge注册，例如AppRegistry模块，如下。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fj46nxl6hfj315y0a2400.jpg" alt=""></p>
<p>第二个问题我们在分析JS调用Native方法的时候再来回答。</p>
<p>Native调用js的过程还是比较简单的，总结一下，可以分为以下几步。</p>
<ol>
<li>在Java层创建js接口类的动态代理</li>
<li>在C++中通过JSCExecutor绑定的callFunctionReturnFlushedQueue函数进入js中</li>
<li>在js中获取需要调用的js模块，调用指定的js方法</li>
</ol>
<h3 id="五、JS调用Native方法"><a href="#五、JS调用Native方法" class="headerlink" title="五、JS调用Native方法"></a>五、JS调用Native方法</h3><p>我们以调用LocationModule为例，这是系统默认提供的获取位置信息的NativeModule，对js暴露了<code>getCurrentPosition(ReadableMap options,final Callback success,Callback error)</code>方法，在js中我们通常会这样调用它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; NativeModules &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line">NativeModules.LocationModule.getCurrentPostion(&#123;...&#125;, (data) =&gt; &#123;&#125;, (err) =&gt; &#123;&#125;)</div></pre></td></tr></table></figure>
<p>首先是导入模块，我们来看看导入的NativeModules是怎样的对象。</p>
<p><img src="quiver-image-url/084468B0E82707528862C750033DDE5C.jpg =942x256" alt="IMAGE"></p>
<p>在Bridge的初始化过程，我们在C++层向global对象绑定过一个对象nativeModuleProxy，它是一个空的对象，但是getProperty方法绑定了一个特殊的c++方法。在js中，我们通过<code>.</code>运算符获取对象属性的时候，底层实现就是执行对象的getProperty方法，那么我们来看一下绑定的这个方法是如何返回js的属性的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JSCExecutor</span></div><div class="line">JSValueRef JSCExecutor::getNativeModule(JSObjectRef object, JSStringRef propertyName) &#123;</div><div class="line">  <span class="comment">//如果获取对象的name属性，那么返回"NativeModules"</span></div><div class="line">  <span class="keyword">if</span> (JSC_JSStringIsEqualToUTF8CString(m_context, propertyName, <span class="string">"name"</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> Value(m_context, String(m_context, <span class="string">"NativeModules"</span>));</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//从JSCNativeModules获取对象，传入js的执行上下文和属性名称</span></div><div class="line">  <span class="keyword">return</span> m_nativeModules.getModule(m_context, propertyName);</div><div class="line">&#125;</div><div class="line"><span class="comment">//JSCNativeModules</span></div><div class="line">JSValueRef JSCNativeModules::getModule(JSContextRef context, JSStringRef jsName) &#123;</div><div class="line">  </div><div class="line">  <span class="comment">//获取模块名称</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> moduleName = String::ref(context, jsName).str();</div><div class="line">  </div><div class="line">  <span class="comment">//在缓存中寻找模块对象，如果找到就直接返回</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> it = m_objects.find(moduleName);</div><div class="line">  <span class="keyword">if</span> (it != m_objects.end()) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;JSObjectRef&gt;(it-&gt;second);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//创建模块对象</span></div><div class="line">  <span class="keyword">auto</span> <span class="keyword">module</span> = createModule(moduleName, context);</div><div class="line">  </div><div class="line">  <span class="comment">//放入缓存</span></div><div class="line">  <span class="keyword">auto</span> result = m_objects.emplace(<span class="built_in">std</span>::move(moduleName), <span class="built_in">std</span>::move(*<span class="keyword">module</span>)).first;</div><div class="line">  <span class="comment">//返回</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;JSObjectRef&gt;(result-&gt;second);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">folly::Optional&lt;Object&gt; JSCNativeModules::createModule(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, JSContextRef context) &#123;</div><div class="line">  <span class="comment">//如果没有缓存过__fbGenNativeModule方法，先缓存一下</span></div><div class="line">  <span class="comment">//__fbGenNativeModule是js中放在global对象上的一个方法，它实现我们在下面会看到</span></div><div class="line">  <span class="keyword">if</span> (!m_genNativeModuleJS) &#123;</div><div class="line">    <span class="keyword">auto</span> global = Object::getGlobalObject(context);</div><div class="line">    m_genNativeModuleJS = global.getProperty(<span class="string">"__fbGenNativeModule"</span>).asObject();</div><div class="line">    m_genNativeModuleJS-&gt;makeProtected();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//根据模块的名称，从注册的原生模块m_moduleRegistry上获取模块信息</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="keyword">auto</span> result = m_moduleRegistry-&gt;getConfig(name);</div><div class="line">  <span class="keyword">if</span> (!result.hasValue()) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//执行__fbGenNativeModule方法，传入的是模块信息和模块的index值，返回一个js对象。</span></div><div class="line">  Value moduleInfo = m_genNativeModuleJS-&gt;callAsFunction(&#123;</div><div class="line">    Value::fromDynamic(context, result-&gt;config),</div><div class="line">    Value::makeNumber(context, result-&gt;index)</div><div class="line">  &#125;);</div><div class="line">  </div><div class="line">  <span class="comment">//返回js对象中的module属性，即原生模块在js上的一个映射</span></div><div class="line">  <span class="keyword">return</span> moduleInfo.asObject().getProperty(<span class="string">"module"</span>).asObject();</div><div class="line">&#125;</div><div class="line"></div><div class="line">folly::Optional&lt;ModuleConfig&gt; ModuleRegistry::getConfig(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) &#123;</div><div class="line">  <span class="comment">//初始化模块名称数组</span></div><div class="line">  <span class="keyword">if</span> (modulesByName_.empty() &amp;&amp; !modules_.empty()) &#123;</div><div class="line">    moduleNames();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//根据模块名称获取index值  </span></div><div class="line">  <span class="keyword">auto</span> it = modulesByName_.find(name);</div><div class="line"></div><div class="line">  <span class="comment">//在注册的原生模块中找到对应的实例</span></div><div class="line">  NativeModule* <span class="keyword">module</span> = modules_[it-&gt;second].get();</div><div class="line">  </div><div class="line">  <span class="comment">//创建config</span></div><div class="line">  folly::dynamic config = folly::dynamic::<span class="built_in">array</span>(name);</div><div class="line">  </div><div class="line">  <span class="comment">//Step 1: 放入原生模块暴露的constant值</span></div><div class="line">  config.push_back(<span class="keyword">module</span>-&gt;getConstants());</div><div class="line">  </div><div class="line">  <span class="comment">//Step 2: 放入原生模块暴露的方法</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MethodDescriptor&gt; methods = <span class="keyword">module</span>-&gt;getMethods();</div><div class="line">  </div><div class="line">  folly::dynamic methodNames = folly::dynamic::<span class="built_in">array</span>;</div><div class="line">  folly::dynamic promiseMethodIds = folly::dynamic::<span class="built_in">array</span>;</div><div class="line">  folly::dynamic syncMethodIds = folly::dynamic::<span class="built_in">array</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; descriptor : methods) &#123;</div><div class="line">      <span class="comment">//放入方法的名称</span></div><div class="line">      methodNames.push_back(<span class="built_in">std</span>::move(descriptor.name));</div><div class="line">      <span class="comment">//promise方法和sync方法分类</span></div><div class="line">      <span class="keyword">if</span> (descriptor.type == <span class="string">"promise"</span>) &#123;</div><div class="line">        promiseMethodIds.push_back(methodNames.size() - <span class="number">1</span>);</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (descriptor.type == <span class="string">"sync"</span>) &#123;</div><div class="line">        syncMethodIds.push_back(methodNames.size() - <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//Step 3: 放入方法名称数组</span></div><div class="line">  config.push_back(<span class="built_in">std</span>::move(methodNames));</div><div class="line">  <span class="comment">//Step 4: 放入promise方法的index</span></div><div class="line">  config.push_back(<span class="built_in">std</span>::move(promiseMethodIds));</div><div class="line">  <span class="comment">//Step 5: 放入sync方法的index</span></div><div class="line">  config.push_back(<span class="built_in">std</span>::move(syncMethodIds));</div><div class="line">  </div><div class="line">  <span class="comment">//创建ModuleConfig对象</span></div><div class="line">  <span class="keyword">return</span> ModuleConfig(&#123;it-&gt;second, config&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getConfig方法返回的是一个一个对象，结构大致如下：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"index"</span>: <span class="number">0</span>,</div><div class="line">  <span class="string">"config"</span>: [</div><div class="line">    <span class="comment">//constants</span></div><div class="line">    &#123;...&#125;,</div><div class="line">    <span class="comment">//MethodDescriptor数组</span></div><div class="line">    [...],</div><div class="line">    <span class="comment">//方法名称数组</span></div><div class="line">    [...],</div><div class="line">    <span class="comment">//promise方法的index值数组</span></div><div class="line">    [...],</div><div class="line">    <span class="comment">//sync方法的index值数组</span></div><div class="line">    [...]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中最重要的是获取MethodDescriptor数组，我们仔细看一下实现方式，入口在C++的NativeModule.getMethods()方法中，在前面我们知道，这个对象的实例是一个对java层的NativeModule的包装，因此实现在java的JavaModuleWrapper中，我们跳回java中看一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 获取MethodDescriptor</span></div><div class="line"><span class="comment"> **/</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;MethodDescriptor&gt; <span class="title">getMethodDescriptors</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mDescs.isEmpty()) &#123;</div><div class="line">      findMethods();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mDescs;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findMethods</span><span class="params">()</span> </span>&#123;</div><div class="line">  Set&lt;String&gt; methodNames = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">  <span class="comment">//原生模块的类</span></div><div class="line">  Class&lt;? extends NativeModule&gt; classForMethods = mModuleClass;</div><div class="line">  <span class="comment">//获取类上声明的所有方法</span></div><div class="line">  Method[] targetMethods = classForMethods.getDeclaredMethods();</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (Method targetMethod : targetMethods) &#123;</div><div class="line">    <span class="comment">//获取包含ReactMethod注解的方法</span></div><div class="line">    ReactMethod annotation = targetMethod.getAnnotation(ReactMethod.class);</div><div class="line">    <span class="comment">//不允许注册重载的方法</span></div><div class="line">    String methodName = targetMethod.getName();</div><div class="line">    <span class="keyword">if</span> (methodNames.contains(methodName)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">            <span class="string">"Java Module "</span> + getName() + <span class="string">" method name already registered: "</span> + methodName);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//创建MethodDescriptor对象</span></div><div class="line">    MethodDescriptor md = <span class="keyword">new</span> MethodDescriptor();</div><div class="line">    <span class="comment">//创建JavaMethod的包装类</span></div><div class="line">    JavaMethodWrapper method = <span class="keyword">new</span> JavaMethodWrapper(<span class="keyword">this</span>, targetMethod, annotation.isBlockingSynchronousMethod());</div><div class="line">    md.name = methodName;</div><div class="line">    md.type = method.getType();</div><div class="line">    <span class="keyword">if</span> (md.type == BaseJavaModule.METHOD_TYPE_SYNC) &#123;</div><div class="line">        md.signature = method.getSignature();</div><div class="line">        md.method = targetMethod;</div><div class="line">    &#125;</div><div class="line">    mMethods.add(method);</div><div class="line">    mDescs.add(md);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取了模块的config之后，我们需要调用一个js方法，将原生的方法注册的js上，也就是调用__fbGenNativeModule，它的实现在NativeModules.js中，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">global.__fbGenNativeModule = genModule;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">genModule</span>(<span class="params">config: ?ModuleConfig, moduleID: number</span>): ?</span>&#123;name: string, <span class="built_in">module</span>?: <span class="built_in">Object</span>&#125; &#123;</div><div class="line">  <span class="keyword">const</span> [moduleName, constants, methods, promiseMethods, syncMethods] = config;</div><div class="line">  <span class="comment">//创建module对象</span></div><div class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = &#123;&#125;;</div><div class="line">  <span class="comment">//对每一个原生的方法，创建一个js的方法，并赋值到module对象上</span></div><div class="line">  methods.forEach(<span class="function">(<span class="params">methodName, methodID</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> isPromise = promiseMethods &amp;&amp; arrayContains(promiseMethods, methodID);</div><div class="line">    <span class="keyword">const</span> isSync = syncMethods &amp;&amp; arrayContains(syncMethods, methodID);</div><div class="line">    <span class="keyword">const</span> methodType = isPromise ? <span class="string">'promise'</span> : isSync ? <span class="string">'sync'</span> : <span class="string">'async'</span>;</div><div class="line">    <span class="comment">//创建js方法，moduleId为原生模块在原生代码的缓存数组的index值，methodId同理</span></div><div class="line">    <span class="built_in">module</span>[methodName] = genMethod(moduleID, methodID, methodType);</div><div class="line">  &#125;);</div><div class="line">  <span class="comment">//赋值原生constants到module对象</span></div><div class="line">  <span class="built_in">Object</span>.assign(<span class="built_in">module</span>, constants);</div><div class="line">  <span class="comment">//返回</span></div><div class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: moduleName, <span class="built_in">module</span> &#125;;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 创建js方法</span></div><div class="line"><span class="comment"> **/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">genMethod</span>(<span class="params">moduleID: number, methodID: number, type: MethodType</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> fn = <span class="literal">null</span>;</div><div class="line">  <span class="comment">//如果是promise类型的方法，则执行BatchedBridge.enqueueNativeCall函数</span></div><div class="line">  <span class="keyword">if</span> (type === <span class="string">'promise'</span>) &#123;</div><div class="line">    fn = <span class="function"><span class="keyword">function</span>(<span class="params">...args: Array&lt;any&gt;</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        BatchedBridge.enqueueNativeCall(moduleID, methodID, args,</div><div class="line">          (data) =&gt; resolve(data),</div><div class="line">          (errorData) =&gt; reject(createErrorFromErrorData(errorData)));</div><div class="line">      &#125;);</div><div class="line">    &#125;;</div><div class="line">  <span class="comment">//如果是sync类型的方法，则执行global.nativeCallSyncHook方法</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'sync'</span>) &#123;</div><div class="line">    fn = <span class="function"><span class="keyword">function</span>(<span class="params">...args: Array&lt;any&gt;</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> global.nativeCallSyncHook(moduleID, methodID, args);</div><div class="line">    &#125;;</div><div class="line">  <span class="comment">//如果是其他类型，则执行BatchedBridge.enqueueNativeCall方法</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    fn = <span class="function"><span class="keyword">function</span>(<span class="params">...args: Array&lt;any&gt;</span>) </span>&#123;</div><div class="line">      <span class="comment">//...</span></div><div class="line">      BatchedBridge.enqueueNativeCall(moduleID, methodID, args, onFail, onSuccess);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  fn.type = type;</div><div class="line">  <span class="keyword">return</span> fn;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，我们已经在js中创建了一个原生模块的映射对象，这个对象有点类似java中的动态代理对象，因为对这个对象上的方法的访问都会通过统一的入口，BatchedBridge.enqueueNativeCall执行。</p>
<p>我们回到最初的例子，此时我们已经获得了LocationModule，然后需要执行它的<code>getCurrentPostion</code>方法，由于getCurrentPostion方法不是一个同步方法，并且也不包含promise入参，所以它执行的是<code>BatchedBridge.enqueueNativeCall(moduleID, methodID, args, onFail, onSuccess)</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">enqueueNativeCall(moduleID, methodID, params, onFail, onSucc) &#123;</div><div class="line">    <span class="comment">//如果包含了success/fail callback，那么用callId对这两个callback生成两个标记位</span></div><div class="line">    <span class="comment">//标记位放入params中，但是callback存入对应的数组中</span></div><div class="line">    <span class="keyword">if</span> (onFail || onSucc) &#123;</div><div class="line">      onFail &amp;&amp; params.push(<span class="keyword">this</span>._callID &lt;&lt; <span class="number">1</span>);</div><div class="line">      onSucc &amp;&amp; params.push((<span class="keyword">this</span>._callID &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>);</div><div class="line">      <span class="keyword">this</span>._successCallbacks[<span class="keyword">this</span>._callID] = onSucc;</div><div class="line">      <span class="keyword">this</span>._failureCallbacks[<span class="keyword">this</span>._callID] = onFail;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//callId自增</span></div><div class="line">    <span class="keyword">this</span>._callID++;</div><div class="line">    </div><div class="line">    <span class="comment">//向_queue的第0位加入本次调用的moduleId</span></div><div class="line">    <span class="keyword">this</span>._queue[MODULE_IDS].push(moduleID);</div><div class="line">    <span class="comment">//向_queue的第1位加入本次调用的methodId</span></div><div class="line">    <span class="keyword">this</span>._queue[METHOD_IDS].push(methodID);</div><div class="line">    <span class="comment">//向_queue的第2位加入本次调用的参数</span></div><div class="line">    <span class="keyword">this</span>._queue[PARAMS].push(params);</div><div class="line">    </div><div class="line">    <span class="comment">//如果两次flush之间小于5ms，那么则可以直接flush，否则等待下一次</span></div><div class="line">    <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line">    <span class="keyword">if</span> (global.nativeFlushQueueImmediate &amp;&amp;</div><div class="line">        (now - <span class="keyword">this</span>._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS ||</div><div class="line">         <span class="keyword">this</span>._inCall === <span class="number">0</span>)) &#123;</div><div class="line">      <span class="keyword">var</span> queue = <span class="keyword">this</span>._queue;</div><div class="line">      </div><div class="line">      <span class="keyword">this</span>._queue = [[], [], [], <span class="keyword">this</span>._callID];</div><div class="line">      <span class="keyword">this</span>._lastFlush = now;</div><div class="line">      <span class="comment">//调用native，此时queue中的值是</span></div><div class="line">      <span class="comment">//[[moduleIds],[methodIds],[params],callId]</span></div><div class="line">      global.nativeFlushQueueImmediate(queue);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>global.nativeFlushQueueImmediate是一个C++定义的方法，在Bridge初始化的时候绑定到global对象上的，它的实现是这样的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JSCExecutor</span></div><div class="line"><span class="keyword">void</span> JSCExecutor::flushQueueImmediate(Value&amp;&amp; <span class="built_in">queue</span>) &#123;</div><div class="line">  <span class="keyword">auto</span> queueStr = <span class="built_in">queue</span>.toJSONString();</div><div class="line">  m_delegate-&gt;callNativeModules(*<span class="keyword">this</span>, folly::parseJson(queueStr), <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//JsToNativeBridge</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">callNativeModules</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">      JSExecutor&amp; executor, folly::dynamic&amp;&amp; calls, <span class="keyword">bool</span> isEndOfBatch)</span> override </span>&#123;</div><div class="line">    <span class="comment">//解析js传过来的queue</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; call : parseMethodCalls(<span class="built_in">std</span>::move(calls))) &#123;</div><div class="line">      <span class="comment">//调用指定的原生模块方法</span></div><div class="line">      m_registry-&gt;callNativeMethod(call.moduleId, call.methodId, <span class="built_in">std</span>::move(call.arguments), call.callId);</div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//JavaNativeModule</span></div><div class="line"><span class="keyword">void</span> JavaNativeModule::invoke(<span class="keyword">unsigned</span> <span class="keyword">int</span> reactMethodId, folly::dynamic&amp;&amp; params, <span class="keyword">int</span> callId) &#123;</div><div class="line">  <span class="comment">//在native执行队列执行js对原生的调用</span></div><div class="line">  messageQueueThread_-&gt;runOnQueue([<span class="keyword">this</span>, reactMethodId, params=<span class="built_in">std</span>::move(params), callId] &#123;</div><div class="line">    <span class="comment">//执行java对象JavaModuleWrapper的invoke方法</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> invokeMethod = wrapper_-&gt;getClass()-&gt;getMethod&lt;<span class="keyword">void</span>(jint, ReadableNativeArray::javaobject)&gt;(<span class="string">"invoke"</span>);</div><div class="line">    invokeMethod(</div><div class="line">      wrapper_,</div><div class="line">      <span class="keyword">static_cast</span>&lt;jint&gt;(reactMethodId),</div><div class="line">      ReadableNativeArray::newObjectCxxArgs(<span class="built_in">std</span>::move(params)).get());</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相比于原生执行js的流程，js执行原生代码的流程就稍微复杂一下，总结一下有以下几步。</p>
<ol>
<li>C++中创建原生模块路由对象nativeMoudleProxy，绑定getNativeMoudles函数作为路由函数，将路由对象挂到js的global对象上</li>
<li>以懒加载的形式创建原生模块在js的代理对象，并为每一个原生模块暴露的方法创建一个代理方法</li>
<li>js调用原生模块代理对象的代理方法，实际方法的执行委托到<code>BatchedBridge.enqueueNativeCall</code>函数。</li>
<li>对js的方法调用进行封装，每一个调用都被封装成一个四元组，[moduleId, methodId, params, callId],将四元组通过nativeFlushQueueImmediate传入C++层Bridge</li>
<li>Bridge中解四元组，还原成对原生模块的方法调用，并执行调用。</li>
</ol>
</div><div class="tags"></div><div class="post-nav"><a href="/MBR加载实验/" class="next">MBR加载实验</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Gradle/">Gradle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/">ReactNative</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作/">工作</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/插件化/">插件化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机/">计算机</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">chenlong's.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>