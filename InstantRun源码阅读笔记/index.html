<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个Android开发者的成长记录"><title>InstantRun源码阅读笔记 | chenlong's</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?c429fdd6ac00b6f7e59c44c7b27894b8";
var s = document.getElementsByTagName("script")[0]; 
s.parentNode.insertBefore(hm, s);
})();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">InstantRun源码阅读笔记</h1><a id="logo" href="/.">chenlong's</a><p class="description">Android开发技术博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 全部</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">InstantRun源码阅读笔记</h1><div class="post-meta">Jan 19, 2017<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="post-content"><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>源码版本 tag:studio-2.2<br><a href="https://android.googlesource.com/platform/tools/base/" target="_blank" rel="external">https://android.googlesource.com/platform/tools/base/</a><br>platform/tools/base/instant-run<br>工程结构<br><img src="https://ww3.sinaimg.cn/large/006tNbRwly1feppycmu6tj311w0l6ack.jpg" alt=""><br>其中instant-run-server及其依赖会被打包进apk，Android Studio使用client和客户端内的server进行通信。建立这个通信的基础是使用adb，google提供了ddmlib来通过adb建立socket连接。</p>
<p>使用instant run 打包<br><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fepq669a3yj311u080t9u.jpg" alt=""></p>
<p>注意以下几点</p>
<ol>
<li>AndroidManifest中，应用的Application被修改为android:name=”com.android.tools.fd.runtime.BootstrapApplication”</li>
<li>主dex中只包含一个类<br><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fepqaktjb3j30uc07wdhi.jpg" alt=""><br>applicationClass: 应用的实际Application全类名<br>applicationId：应用包名<br>token：app内的server和ide进行通信的认证token，通过校验token是否一致来确保连接安全<br>usingApkSplits：如果开启apk split，那么将使用原生的apk split方法来分割工程，在默认状态下，是按照dex的方式分割工程。</li>
<li>classes2.dex包含了instant run的运行时，这只是一个壳工程。</li>
<li>instant-run.zip包含了所有的业务代码。<br><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fepqm2yge1j312u0maq94.jpg" alt=""><br>每一个jar包会被打成一个dex文件，同时我们的业务代码也会被拆分成10个dex在本例中，slice-7-classes.dex包含了我们自己的业务代码，slice_4-classes.dex包含了support-appcompat-v7中的R。</li>
</ol>
<p>几种swap方式：<br>hot swap：不需要重新进程，不需要重启Activity。仅针对修改方法实现<br>warm swap：重启当前Activity。重新加载资源<br>cold swap：重启进程。对类的结构改变<br>reinstall：AndroidManifest.xml的修改</p>
<p>总结<br>从观察instant run的生成的apk来看，我们可以猜测它的原理，通过壳工程动态加载业务dex，差量编译，根据不同的修改情况选择不同的策略对壳工程中的内容进行更新。<br>接下来，我们根据源码，回答以下问题</p>
<ol>
<li>instant run可以用在dalvik平台下吗？</li>
<li>hot/warm/cold swap是如何做到的？</li>
<li>apk split 是一个怎样的机制</li>
</ol>
<h2 id="二、BootstrapApplication"><a href="#二、BootstrapApplication" class="headerlink" title="二、BootstrapApplication"></a>二、BootstrapApplication</h2><p>作为壳工程的Application，BootstrapApplication负责启动instant run的运行时并加载我们的业务代码，下面我们具体看看它的实现</p>
<h3 id="1-attachBaseContext"><a href="#1-attachBaseContext" class="headerlink" title="1. attachBaseContext"></a>1. attachBaseContext</h3><h4 id="绑定context"><a href="#绑定context" class="headerlink" title="绑定context"></a>绑定context</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context context)</span></span>&#123;</div><div class="line">  </div><div class="line">  <span class="comment">//原生的apk split机制支持将apk分割成多个apk并安装，并且能够从分割后的</span></div><div class="line">  <span class="comment">//apk中加载资源和类，因此开启apkAplits后，不需要对加载类和加载资源做</span></div><div class="line">  <span class="comment">//额外的处理</span></div><div class="line">  <span class="keyword">if</span> (!AppInfo.usingApkSplits) &#123;</div><div class="line">    String apkFile = context.getApplicationInfo().sourceDir;</div><div class="line">    <span class="keyword">long</span> apkModified = apkFile != <span class="keyword">null</span> ? </div><div class="line">                <span class="keyword">new</span> File(apkFile).lastModified() : <span class="number">0L</span>;</div><div class="line">    <span class="comment">//创建资源</span></div><div class="line">    createResources(apkModified);</div><div class="line">    <span class="comment">//创建classloader</span></div><div class="line">    setupClassLoaders(</div><div class="line">            context, </div><div class="line">            context.getCacheDir().getPath(), </div><div class="line">            apkModified);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//创建应用真正的Application</span></div><div class="line">  createRealApplication();</div><div class="line"></div><div class="line">  </div><div class="line">  <span class="comment">//绑定context到壳工程的application和真正的application</span></div><div class="line">  <span class="keyword">super</span>.attachBaseContext(context);</div><div class="line">  <span class="keyword">if</span> (realApplication != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Method attachBaseContext =</div><div class="line">          ContextWrapper.class</div><div class="line">                  .getDeclaredMethod(<span class="string">"attachBaseContext"</span>,</div><div class="line">                                      Context.class);</div><div class="line">      attachBaseContext.setAccessible(<span class="keyword">true</span>);</div><div class="line">      attachBaseContext.invoke(realApplication, context);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建资源createResource"><a href="#创建资源createResource" class="headerlink" title="创建资源createResource"></a>创建资源createResource</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createResources</span><span class="params">(<span class="keyword">long</span> apkModified)</span> </span>&#123;</div><div class="line"><span class="comment">/* </span></div><div class="line"><span class="comment">基础路径：</span></div><div class="line"><span class="comment">"/data/data/$&#123;applicationId&#125;/files/instant-run"</span></div><div class="line"><span class="comment">传入路径：</span></div><div class="line"><span class="comment">"$&#123;基础路径&#125;/inbox/resources.ap_";</span></div><div class="line"><span class="comment">激活路径：</span></div><div class="line"><span class="comment">"$&#123;基础路径&#125;/left(right)/resources.ap_"</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Step 1：从传入路径读取在server还没有启动之前传入的resource.ap_文件</span></div><div class="line"><span class="comment">Step 2: 判断当前的激活路径</span></div><div class="line"><span class="comment">  激活路径有两个，right和left，判断逻辑如下：</span></div><div class="line"><span class="comment">  如果"$&#123;基础路径&#125;/active"文件不存在，那么left为激活状态</span></div><div class="line"><span class="comment">  如果"$&#123;基础路径&#125;/active"文件存在，则文件中写入了当前是left还是right为激活状态</span></div><div class="line"><span class="comment">Step 3: 向非激活路径写入resource.ap_数据。即，如果当前的激活路径为left，则向right写入数据。</span></div><div class="line"><span class="comment">Step 4: 更改当前的激活路径为相反的一个。即，如果当前为left，则更改为right。</span></div><div class="line"><span class="comment">*/</span></div><div class="line">  FileManager.checkInbox();</div><div class="line">  </div><div class="line">  <span class="comment">// 获取当前的资源文件路径</span></div><div class="line">  File file = FileManager.getExternalResourceFile();</div><div class="line">  externalResourcePath = file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>;</div><div class="line">  <span class="comment">//判断当前资源文件是否失效</span></div><div class="line">  <span class="keyword">long</span> resourceModified = file.lastModified();</div><div class="line">  <span class="keyword">if</span> (apkModified == <span class="number">0L</span> || resourceModified &lt;= apkModified) &#123;</div><div class="line">    externalResourcePath = <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建classLoader"><a href="#创建classLoader" class="headerlink" title="创建classLoader"></a>创建classLoader</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setupClassLoaders</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">                  Context context,      //上下文</span></span></div><div class="line"><span class="function"><span class="params">                  String codeCacheDir,  //oat文件目录</span></span></div><div class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> apkModified)</span> </span>&#123;   <span class="comment">//壳工程apk文件的修改时间</span></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">    获取dex 列表</span></div><div class="line"><span class="comment">    </span></div><div class="line"><span class="comment">  */</span></div><div class="line">  List&lt;String&gt; dexList = FileManager.getDexList(context, apkModified);</div><div class="line">  </div><div class="line">  <span class="comment">//获取壳工程的classloader  </span></div><div class="line">  ClassLoader classLoader = BootstrapApplication.class.getClassLoader();</div><div class="line">  <span class="comment">//获取so库的路径</span></div><div class="line">  nativeLibraryPath=(String)classLoader.getClass()</div><div class="line">                    .getMethod(<span class="string">"getLdLibraryPath"</span>).invoke(classLoader);</div><div class="line">  </div><div class="line">  <span class="comment">//注入classLoader</span></div><div class="line">  IncrementalClassLoader.inject(</div><div class="line">                    classLoader,</div><div class="line">                    nativeLibraryPath,</div><div class="line">                    codeCacheDir,</div><div class="line">                    dexList);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相比于资源文件的加载，classloader的初始化要复杂一些，主要分为两点：</p>
<ol>
<li>获取所有可用的dex文件。</li>
<li>将IncrementalClassLoader注入到壳工程的classLoader链中。</li>
</ol>
<h4 id="获取所有可用的dex文件"><a href="#获取所有可用的dex文件" class="headerlink" title="获取所有可用的dex文件"></a>获取所有可用的dex文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="function">List&lt;String&gt; <span class="title">getDexList</span><span class="params">(Context context, <span class="keyword">long</span> apkModified)</span> </span>&#123;</div><div class="line">  <span class="comment">//dex文件夹</span></div><div class="line">  <span class="comment">//路径: /data/data/$&#123;applicationId&#125;/instant-run/dex</span></div><div class="line">  File dexFolder = getDexFileFolder(dataFolder, <span class="keyword">false</span>);</div><div class="line">  File[] dexFiles;</div><div class="line">  <span class="keyword">if</span>(第一次安装)&#123;</div><div class="line">    <span class="number">1</span>. 打开壳工程中的instant-run.zip文件</div><div class="line">    <span class="number">2</span>. 遍历所有的压缩项</div><div class="line">    <span class="number">3</span>. 将根目录下所有后缀为dex的文件解压到dex文件夹</div><div class="line">    <span class="number">4</span>. 修改解压后的文件名，为所有文件增加<span class="string">"slice-"</span>前缀</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    dexFiles = dexFolder.listFiles();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//获取最新的hotSwap更新时间</span></div><div class="line">  <span class="keyword">long</span> newestHotswapPatch = FileManager</div><div class="line">                          .getMostRecentTempDexTime(dataFolder);</div><div class="line">  </div><div class="line">  <span class="keyword">long</span> newestColdswapPatch = apkModified;</div><div class="line">  <span class="keyword">if</span>(不是第一次安装)&#123;</div><div class="line">    <span class="comment">//计算最旧的ColdSwap更新时间oldestColdSwapPatch</span></div><div class="line">    <span class="comment">//计算最新的ColdSwap更新时间newsetColdSwapPatch</span></div><div class="line">    <span class="keyword">long</span> oldestColdSwapPatch = apkModified;</div><div class="line">    <span class="keyword">for</span> (File dex : dexFiles) &#123;</div><div class="line">      <span class="keyword">long</span> dexModified = dex.lastModified();</div><div class="line">      oldestColdSwapPatch = Math.min(dexModified, oldestColdSwapPatch);</div><div class="line">      newestColdswapPatch = Math.max(dexModified, newestColdswapPatch);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">      当前dex文件夹下至少包含一个dex文件比壳工程要旧，也就是说</span></div><div class="line"><span class="comment">      当前的dex文件夹下的文件不是最新的，所以重新从instant-run.zip</span></div><div class="line"><span class="comment">      中解压一次，逻辑如下：</span></div><div class="line"><span class="comment">      1. 如果dex文件夹下已经存在的文件比apk中的新，那么不解压</span></div><div class="line"><span class="comment">      2. 如果dex文件夹下已经存在的文件不在apk中，那么删除dex文件夹下的文件。</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keyword">if</span> (oldestColdSwapPatch &lt; apkModified) &#123;</div><div class="line">      dexFiles = extractSlices(dexFolder, dexFiles, apkModified);</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newestHotswapPatch &gt; <span class="number">0L</span>)&#123;</div><div class="line">    <span class="comment">//如果是第一次安装，则删除所有的hot swap 文件</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">  正常情况下，重新初始化classloader是冷更新，那么冷更新的时间一定比热更新时间新。</span></div><div class="line"><span class="comment">  但是如果在推送了一次热更新的情况下，手动重启app，此时热更新的时间就比冷更新的时间新，但是热更新的代码并不会加载。</span></div><div class="line"><span class="comment">  */</span></div><div class="line">  <span class="keyword">if</span> (newestHotswapPatch &gt; newestColdswapPatch) &#123;</div><div class="line">    showToast(<span class="string">"Your app does not have the latest code changes because it "</span></div><div class="line">          + <span class="string">"was restarted manually. Please run from IDE instead."</span>)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">    看注释应该是想按照更新时间排序，但是实际的实现似乎是按照字母降序排列？</span></div><div class="line"><span class="comment">  */</span></div><div class="line">  Collections.sort(dexFiles, Collections.reverseOrder());</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> dexFiles;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>instant run的运行时走到这里，需要加载的resource，dex文件已经准备好了，我们重新回顾一下。</p>
<p>首先是资源文件resource.ap_，它的加载路径是/data/data/${applicationId}/instant-run/left(right)/resource.ap—。需要重点关注的地方是left和right的交替激活策略，为什么需要这样做是因为我们需要在程序运行时更新resource.ap文件，由于程序启动时，通过内存映射已经加载了resource.ap文件，更新资源时，我们并不会重新进程，所以我们无法在同一个路径更新它，所以只能通过两个文件交替进行。</p>
<p>其次是dex文件，它的加载路径是/data/data/${applicationId}/instant-run/dex文件夹。<br><img src="http://ww3.sinaimg.cn/large/006tNbRwly1fequb3eod2j315r0bngrr.jpg" alt=""><br>dex的加载逻辑可以分为两种，第一次安装和增量<br><strong>第一次安装</strong><br>将打包进apk的instant-run.zip文件解压到dex目录下，并且将所有的hotswap文件删除<br><strong>增量</strong><br>计算当前dex目录下最新和最旧的dex更新时间，如果最旧的更新时间小于apk的安装时间，说明instant-run.zip文件有更新，此时将更新的dex文件解压到dex目录，并删除instant-run.zip中不存在的已经解压的dex文件。</p>
<p><strong><em>这里我们有一个疑问，我们知道，我们是无法直接更新一个已经被映射到内存的dex文件，这样必然导致crash，那么更新dex的时机一定是在进程重启的时候，可是按照目前的逻辑，重新解压instant-run.zip的条件是dex目录下存在一个dex文件的更新时间比apk的安装时间早，那么我们如何在不重新安装apk的情况下触发这个条件呢？</em></strong></p>
<p>收到cold swap的请求之后，直接在dex目录下写文件，没有任何buffer措施，如何避免crash？？？？？</p>
<p>这个地方需要先搞清楚类加载的流程。</p>
<p>接下来，我们需要hook一些系统加载资源和类的代码，让壳工程加载实际的业务代码。</p>
<h3 id="将IncrementalClassLoader注入到壳工程的classLoader链中"><a href="#将IncrementalClassLoader注入到壳工程的classLoader链中" class="headerlink" title="将IncrementalClassLoader注入到壳工程的classLoader链中"></a>将IncrementalClassLoader注入到壳工程的classLoader链中</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">inject</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">            ClassLoader classLoader, //壳工程的classloader</span></span></div><div class="line"><span class="function"><span class="params">            String nativeLibraryPath,//壳工程的so加载路径</span></span></div><div class="line"><span class="function"><span class="params">            String codeCacheDir,     //壳工程的oat文件路径</span></span></div><div class="line"><span class="function"><span class="params">            List&lt;String&gt; dexes)</span> </span>&#123;    <span class="comment">//实际的业务代码的dex路径</span></div><div class="line">  <span class="comment">//创建IncrementalClassLoader</span></div><div class="line">  <span class="comment">//IncrementalClassLoader的构造函数中会创建一个DelegateClassLoader,</span></div><div class="line">  <span class="comment">//所有的类加载过程都是由DelegateClassLoader完成的。</span></div><div class="line">  IncrementalClassLoader incrementalClassLoader =</div><div class="line">                <span class="keyword">new</span> IncrementalClassLoader(</div><div class="line">                        classLoader, </div><div class="line">                        nativeLibraryPath, </div><div class="line">                        codeCacheDir, </div><div class="line">                        dexes);</div><div class="line">  <span class="comment">//把新创建的classloader设置为当前pathclassloader的父加载器</span></div><div class="line">  setParent(classLoader, incrementalClassLoader);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述的<code>inject</code>过程让当前的classloader体系变成了如下图所示的情况，</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNbRwly1feqwpv6fm7j30wi0gs75l.jpg" alt=""></p>
<p>看上去有些复杂，但是我们用一个实例来分析一下这种classloader体系下的类加载流程。</p>
<p>假设在壳工程中包含一个类com.qiyu.wbg.A，在实际业务代码中包含一个类com.qiyu.wbg.B。首先加载A，它的加载路径如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">开始</div><div class="line"><span class="number">1</span>. PathClassLoader.loadClass()</div><div class="line">  <span class="number">2</span>. IncrementalClassLoader.loadClass()</div><div class="line">    <span class="number">3</span>. BootClassLoader.loadClass()</div><div class="line">  <span class="number">4</span>. IncrementalClassLoader.findClass()</div><div class="line">    <span class="number">5</span>. DelegateClassLoader.findClass()</div><div class="line">      <span class="number">6</span>. BaseDexClassLoader.findClass()</div><div class="line"><span class="number">7</span>. PathClassLoader.findClass()</div><div class="line">加载结束</div></pre></td></tr></table></figure>
<p>然后加载B，它的加载路径如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">开始</div><div class="line"><span class="number">1</span>. PathClassLoader.loadClass()</div><div class="line">  <span class="number">2</span>. IncrementalClassLoader.loadClass()</div><div class="line">    <span class="number">3</span>. BootClassLoader.loadClass()</div><div class="line">  <span class="number">4</span>. IncrementalClassLoader.findClass()</div><div class="line">    <span class="number">5</span>. DelegateClassLoader.findClass()</div><div class="line">      <span class="number">6</span>. BaseDexClassLoader.findClass()</div><div class="line">加载结束</div></pre></td></tr></table></figure>
<p>其中DelegateClassLoader并不是ClassLoader链上的一员，它的作用只是协助IncrementalClassLoader加载dex文件中的类，它的loadClass()方法始终都不会调用，我们不妨把它作为一个工具类，而不是一个classloader，这样，简化后的classLoader体系如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNbRwly1fer2x7oft1j30ok0d2t9p.jpg" alt=""></p>
<p>至此，我们已经分析完了<code>attachBaseContext</code>中的绝大数代码，包括初始化资源的加载路径，初始化dex文件列表，注入classLoader，剩下的代码还有三行，我们来看看做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">//创建实际的Application</span></div><div class="line">createRealApplication();</div><div class="line"><span class="comment">//调用父类的同名方法，完成context的绑定</span></div><div class="line"><span class="keyword">super</span>.attachBaseContext(context);</div><div class="line"></div><div class="line"><span class="comment">//反射执行实际Application的attachBaseContext方法，</span></div><div class="line"><span class="comment">//将context绑定到实际的Application上。</span></div><div class="line">Method attachBaseContext = ContextWrapper.class.getDeclaredMethod(</div><div class="line">                                <span class="string">"attachBaseContext"</span>, </div><div class="line">                                Context.class);</div><div class="line">attachBaseContext.setAccessible(<span class="keyword">true</span>);</div><div class="line">attachBaseContext.invoke(realApplication, context);</div></pre></td></tr></table></figure>
<h3 id="2-onCreate"><a href="#2-onCreate" class="headerlink" title="2. onCreate()"></a>2. onCreate()</h3><p>接下来，我们进入application的生命周期函数，看看BootstrapApplication在这里做了些什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">if</span> (!AppInfo.usingApkSplits) &#123;</div><div class="line">    <span class="comment">//反射替换所有使用Application的地方，将BootstrapApplication实例替换为实际的Application实例</span></div><div class="line">    MonkeyPatcher.monkeyPatchApplication(</div><div class="line">                    BootstrapApplication.<span class="keyword">this</span>,</div><div class="line">                    BootstrapApplication.<span class="keyword">this</span>,</div><div class="line">                    realApplication, externalResourcePath);</div><div class="line">    <span class="comment">//反射替换所有的AssetManager实例，用实际的resource.ap_替换壳工程的resource路径</span></div><div class="line">    MonkeyPatcher.monkeyPatchExistingResources(</div><div class="line">                    BootstrapApplication.<span class="keyword">this</span>,</div><div class="line">                    externalResourcePath, <span class="keyword">null</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    MonkeyPatcher.monkeyPatchApplication(</div><div class="line">                    BootstrapApplication.<span class="keyword">this</span>,</div><div class="line">                    BootstrapApplication.<span class="keyword">this</span>,</div><div class="line">                    realApplication, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//壳工程Application onCreate生命周期</span></div><div class="line">  <span class="keyword">super</span>.onCreate();</div><div class="line">  </div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">    创建Server的逻辑</span></div><div class="line"><span class="comment">    1. 如果只有一个进程，直接启动server</span></div><div class="line"><span class="comment">    2. 如果有多个进程，根据application id找到主进程，并在主进程启动server</span></div><div class="line"><span class="comment">    3. 如果有多个进程，但是根据application id没有找到主进程，那么在每一个进程中都启动一个server</span></div><div class="line"><span class="comment">  */</span></div><div class="line">  Server.create(AppInfo.applicationId,</div><div class="line">                BootstrapApplication.<span class="keyword">this</span>);</div><div class="line">  </div><div class="line">  <span class="comment">//真正的Application onCreate生命周期</span></div><div class="line">  realApplication.onCreate();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三、Server的创建"><a href="#三、Server的创建" class="headerlink" title="三、Server的创建"></a>三、Server的创建</h2><p>在BootstrapApplication的onCreate方法中，应用在主进程创建了一个Server。这个Server用来和Android Studio通信，从而实现将增量代码推送到app内以及控制App的一些行为。在分析这部分代码之前，我们先简单介绍一下adb这个工具。</p>
<h3 id="1-adb简介"><a href="#1-adb简介" class="headerlink" title="1. adb简介"></a>1. adb简介</h3><p>adb包含三个部分</p>
<ol>
<li>adb server：运行在开发机上，默认监听了5037端口</li>
<li>adbd：运行在设备上，作为守护进程。</li>
<li>client：和adb server建立的连接</li>
</ol>
<p>这三者之间的关系如下：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNbRwly1fes2rb8p2dj30wi0k0dhi.jpg" alt=""></p>
<p>当adb server启动时，首先监听本地5037端口，然后通过tcp以及usb寻找adbd的存在，如果发现了adbd，就会和adbd建立连接。之后我们通过和adb server建立连接从而间接的连接上设备上的adbd。</p>
<p>adb工具提供了非常多的命令来控制设备，我们先学习一下我们即将用到的forward命令。</p>
<p>forward，顾名思义就是用来转发连接的，它的用法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">forward [--no-rebind] LOCAL REMOTE</div><div class="line">  forward socket connection using:</div><div class="line">    1. 转发tcp连接，当用在本地地址时，可以写成tcp:0来使用任意可用端口</div><div class="line">    tcp:&lt;port&gt; (&lt;<span class="built_in">local</span>&gt; may be <span class="string">"tcp:0"</span> to pick any open port) </div><div class="line">    2. 转发IPC</div><div class="line">    localabstract:&lt;unix domain socket name&gt;</div><div class="line">    3. </div><div class="line">    localreserved:&lt;unix domain socket name&gt;</div><div class="line">    4. </div><div class="line">    localfilesystem:&lt;unix domain socket name&gt;</div><div class="line">    5. 转发字符设备</div><div class="line">    dev:&lt;character device name&gt;</div><div class="line">    6. 转发jdwp调试协议，只能用在远程地址</div><div class="line">    jdwp:&lt;process pid&gt; (remote only)</div><div class="line">例如：</div><div class="line">adb forward tcp:5088 localabstract:com.qiyu.wbg.instantrun</div><div class="line">将设备上的IPC域套接字 转发到本地tcp连接的5088端口上</div></pre></td></tr></table></figure>
<p>当连接被转发之后，我们在本地端口上进行操作，就和在设备上进行操作是一样的。例如上面的例子，我们向本地tcp连接的5088端口写入数据，就如同在和设备上的某个进程进行IPC。<br>建立转发之后，我们可以使用<code>adb forward --list</code>来查看所有的转发连接，使用<code>adb forward --remove LOCAL</code>或者<code>adb forward --remove-all</code>断开转发连接。</p>
<p>google为我们提供了ddmlib来简化和adb server建立连接的过程，例如，我们使用如下方式，建立获取当前连接的设备列表。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//TODO ddmlib的演示代码</span></div></pre></td></tr></table></figure>
<h3 id="2-Server的建立"><a href="#2-Server的建立" class="headerlink" title="2. Server的建立"></a>2. Server的建立</h3><p>有了上面的基础，我们来看看Server的建立过程。</p>
<h4 id="Server-create静态方法"><a href="#Server-create静态方法" class="headerlink" title="Server.create静态方法"></a>Server.create静态方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String packageName, Application application)</span> </span>&#123;</div><div class="line">    <span class="comment">//创建 Server实例</span></div><div class="line">    <span class="keyword">new</span> Server(packageName, application);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Server的构造方法"><a href="#Server的构造方法" class="headerlink" title="Server的构造方法"></a>Server的构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Server</span><span class="params">(String packageName,Application application)</span> </span>&#123;</div><div class="line">  mApplication = application;</div><div class="line">  <span class="comment">//以包名创建IPC的server</span></div><div class="line">  mServerSocket = <span class="keyword">new</span> LocalServerSocket(packageName);</div><div class="line">  <span class="comment">//启动Server</span></div><div class="line">  startServer();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="startServer"><a href="#startServer" class="headerlink" title="startServer"></a>startServer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">//创建一个线程，启动IPC server</span></div><div class="line">  Thread socketServerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SocketServerThread());</div><div class="line">  socketServerThread.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SocketServerThread启动后，会等待IPC连接，并为每一个连接创建一个SocketServerReplyThread处理请求。</p>
<p>在SocketServerReplyThread中，handle方法处理了连接中的输入和输出，我们来看一下handle方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(DataInputStream input, DataOutputStream output)</span> </span>&#123;</div><div class="line">  <span class="comment">//读取一个long值作为magic魔数，如果magic不等于0x35107124L，则断开连接</span></div><div class="line">  <span class="keyword">long</span> magic = input.readLong();</div><div class="line">  <span class="keyword">if</span> (magic != PROTOCOL_IDENTIFIER) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//读取一个int值作为version，并返回当前server支持的协议版本，version=4</span></div><div class="line">  <span class="comment">//如果连接的version和server支持version不匹配，那么断开连接</span></div><div class="line">  <span class="keyword">int</span> version = input.readInt();</div><div class="line">  output.writeInt(PROTOCOL_VERSION);</div><div class="line">  <span class="keyword">if</span> (version != PROTOCOL_VERSION) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//循环读取数据，第一个int值作为消息类型，根据不同的消息，进行不同的操作</span></div><div class="line">  <span class="comment">//直到客户端写入MESSAGE_EOF，此时断开连接。</span></div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">int</span> message = input.readInt();</div><div class="line">    <span class="keyword">switch</span> (message) &#123;</div><div class="line">      <span class="keyword">case</span> MESSAGE_EOF:</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      <span class="keyword">case</span> MESSAGE_PING:</div><div class="line">        ...</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      <span class="keyword">case</span> MESSAGE_RESTART_ACTIVITY:</div><div class="line">        ...</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>instant run定义了一个通信协议，这个协议的格式如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNbRwly1fes5iccrj5j30zw0843zg.jpg" alt=""></p>
<p>在Server启动的时候，它以包名创建了一个IPC套接字来进行进程间通信，通信协议如上图所示，还记得刚刚在介绍adb时，学习到forward命令吗？我们可以利用adb将这个IPC套接字转发到开发机的tcp连接上，并与它通信。</p>
<p><strong>步骤一：转发连接</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. 开启adb server</div><div class="line">adb start-server</div><div class="line">2. 转发ipc连接到本地5088端口</div><div class="line">adb forward tcp:5088 localabstract:com.qiyu.wbg.instantrun</div></pre></td></tr></table></figure></p>
<p><strong>步骤二：与instant run server通信</strong></p>
<p>为了和instant run的server通信，我们需要连接本地的5088端口，并按照协议格式写入数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//建立到本地5088的tcp连接</span></div><div class="line">Socket socket= <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">5088</span>);</div><div class="line"><span class="comment">//获取输入流</span></div><div class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</div><div class="line"><span class="comment">//获取输出流</span></div><div class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</div><div class="line"></div><div class="line"><span class="comment">//定义协议字段</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">long</span> magic = <span class="number">0x35107124L</span>;</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> version = <span class="number">4</span>;</div><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> eof = <span class="number">7</span>;</div><div class="line"><span class="keyword">final</span> msg_show_toast = <span class="number">6</span>;</div><div class="line"></div><div class="line"><span class="comment">//写magic</span></div><div class="line">out.writeLong(magic);</div><div class="line"><span class="comment">//写version</span></div><div class="line">out.writeInt(version);</div><div class="line"><span class="comment">//写msg类型</span></div><div class="line">out.writeInt(msg_show_toast);</div><div class="line"><span class="comment">//根据MESSAGE_SHOW_TOAST的定义，写入需要展示数据</span></div><div class="line">out.writeUTF(<span class="string">"this is a test client!!"</span>);</div><div class="line"><span class="comment">//通信结束</span></div><div class="line">out.writeInt(eof);</div><div class="line">out.flush();</div><div class="line"></div><div class="line"><span class="comment">//读取server 返回的协议版本号</span></div><div class="line"><span class="keyword">int</span> protocalVersion = in.readInt();</div><div class="line">System.out.println(<span class="string">"protocal version: "</span>+protocalVersion);</div></pre></td></tr></table></figure>
<p>在客户端上，我们看到如下结果。<br><img src="http://ww1.sinaimg.cn/large/006tNbRwly1fes5z7wwswj30m60fsdg4.jpg" alt=""></p>
<p>至此，我们分析完成了Instant Run 建立server的过程以及Instant Run的通信协议。在实际的使用过程中，Android Studio通过调用instant-run-client来和App内的server通信，将增量更新推送到App内，并根据增量更新的类型控制App执行例如重启进程，重启当前Activity之类的操作。</p>
</div><div class="tags"></div><div class="post-nav"><a href="/AndroidGradlePlugin源码阅读-导入源码/" class="pre">AndroidGradlePlugin源码阅读-导入源码</a><a href="/Tinker源码走读/" class="next">Tinker源码走读</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Gradle/">Gradle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/">ReactNative</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作/">工作</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/插件化/">插件化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机/">计算机</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">chenlong's.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>