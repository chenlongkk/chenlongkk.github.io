<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一个Android开发者的成长记录"><title>插件化之Apk的资源编译 | chenlong's</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?c429fdd6ac00b6f7e59c44c7b27894b8";
var s = document.getElementsByTagName("script")[0]; 
s.parentNode.insertBefore(hm, s);
})();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">插件化之Apk的资源编译</h1><a id="logo" href="/.">chenlong's</a><p class="description">Android开发技术博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 全部</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">插件化之Apk的资源编译</h1><div class="post-meta">Sep 12, 2016<span> | </span><span class="category"><a href="/categories/插件化/">插件化</a></span></div><div class="post-content"><p>写的比较长，可以选择跳过前面2节，直接从<strong>0x03实例分析</strong>开始。如有错误，请不吝指正。</p>
<h3 id="0x00-aapt编译流程"><a href="#0x00-aapt编译流程" class="headerlink" title="0x00 aapt编译流程"></a>0x00 aapt编译流程</h3><p>在之前的Apk编译打包过程分析中，我们使用了一个google提供的一个工具，aapt。主要有两个用途，第一，在编译代码之前通过aapt生成R.java文件。第二，在编译完成代码之后，通过aapt打包所有的资源生成apk。下面我们来简单分析一下aapt是如何进行这两项工作的。</p>
<h4 id="aapt需要干什么？"><a href="#aapt需要干什么？" class="headerlink" title="aapt需要干什么？"></a>aapt需要干什么？</h4><p>aapt主要需要做以下这些事情：</p>
<p><em>1.编译xml文件</em> </p>
<p>编译成二进制的xml文件会加快运行时的解析速度。</p>
<p><em>2.生成R.java/R.txt</em> </p>
<p>aapt在编译的过程中分析收集所有的资源文件，除了assets文件夹下的文件外，其他所有的资源都会分配一个唯一的id，并写入R文件中，这样我们就可以通过R.xx.xxxx的方法在代码中访问资源了。</p>
<p><em>3.生成resource.arsc</em> </p>
<p>arsc文件其实就是一份资源文件的索引，因为在资源中除了文本形式的xml文件以外还有很多非文本类型的资源，例如图片，要获取这些资源，我们需要通过arsc找到他们的存储路径。</p>
<h4 id="Aapt的编译流程"><a href="#Aapt的编译流程" class="headerlink" title="Aapt的编译流程"></a>Aapt的编译流程</h4><p>如果我们略过aapt实际运行时复杂的流程，那么资源处理可以简化成以下过程</p>
<p><img src="http://i4.piimg.com/567571/b3837e2058d1ca27.png" alt=""></p>
<p>其中涉及到了两个关键的数据结构，<code>AaptAssets</code>和<code>ResourceTable</code>，从源码中可以得到这两个结构以及相关类的UML图，如下：</p>
<p><img src="http://img.my.csdn.net/uploads/201304/03/1364933259_8915.jpg" alt="AaptAssets"></p>
<p><img src="http://img.my.csdn.net/uploads/201304/08/1365361779_6191.jpg" alt="ResourceTable"></p>
<p>上面的图可能有些抽象，我们通过一个例子看一下，假设<code>res</code>目录下有一下资源：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-drawable</div><div class="line">    -a.png</div><div class="line">-drawable-xhdpi</div><div class="line">    -a.png</div><div class="line">-drawable-xxhdpi</div><div class="line">    -a.png</div><div class="line">-layout</div><div class="line">    -main_layout.xml</div><div class="line">    -detail_layout.xml</div><div class="line">-values</div><div class="line">    -attrs.xml</div><div class="line">    -strings.xml</div></pre></td></tr></table></figure>
<p>那么，在收集资源阶段AaptAssets的结构类似下面的json字符串</p>
<p><img src="http://i4.piimg.com/567571/73da640476d2320f.png" alt="AaptAssets的结构示意图"></p>
<p>接下来，aapt为每一个收集到资源分配资源id，这个过程中有以下几个地方需要注意：</p>
<ol>
<li>values文件下的资源会被编译成最终值放入resource.arsc。例如colors.xml中，<code>&lt;color name=&quot;background&quot;&gt;#2888e5&lt;/color&gt;</code>会被编译成类似<code>[typeoffset:0x02,keyoffset:0x12,value:0xff2888e5]</code>这样的三元组用来在resource.arsc中定位它的值</li>
<li>类似drawable这样的非文本类型的资源，它的值是它在res目录下的相对路径，并不是它的二进制值</li>
<li>attr中的内容会被编译成带有层级的结构，类似<code>[typeoffset:0x01,keyoffset:0x14,parentStart:0x3f,valueoffset=0x0f2]</code></li>
</ol>
<p>我们还是通过上面提到的例子来看一下ResourceTable的结构，如图</p>
<p><img src="http://i1.piimg.com/567571/37daaaf2f46c5107.png" alt="ResourceTable的结构示意图"></p>
<p>我们知道一个资源的id是一个32位整数，其中前8位是packageID，之后的8位是typeID，最后16位是具体资源的ID，也就是如下的形式：</p>
<p><code>0xPPTTEEEE</code></p>
<p>其中，packageID和typeID在resources.arsc中是确实存在的，但是具体资源ID在arsc中并不存在，它的含义其实是某一个具体资源在当前package，当前Type下的index值。packageId的取值范围是[0x01,0x7f],其中，0x01是系统资源的packageId，应用程序的packageId始终是0x7f，这个特性需要重点关注一下，因为接下来的一些黑科技就是从这里诞生的。typeID虽然在arsc文件中真是存在，但是不要认为它的取值是一个枚举，它和具体资源id一样，表示一个资源类型在当前package下的index值，它的值是从1开始的。</p>
<p>分配完资源id后，接下来要对所有的xml文件进行编译，这里的xml文件不包括values中的文件。编译的具体过程，这里略过不谈，只简单的分析一下思路，大致是这样的，首先读取一个xml文件，在内存中，这个xml文件以一棵树的形式存在，然后遍历这棵树，将所有具有资源id的属性名和属性值换成id，然后收集所有的字符串，写入字符串常量池，xml中对字符串的引用全部换成对常量池的索引，之后压平这棵将树，最后将处理后的结构写入文件就完成了一个xml文件的编译，具体的过程当然要比这个复杂很多，但是我们要理解这样做的原因，第一，通过字符串常量池处理所有的字符串能够过滤重复的字符串，减少xml的体积。第二，对于有资源id的属性名和属性值直接替换成id之后能够加快运行时对xml文件的解析。对xml文件的处理有点类似dex文件压缩class文件的方式，都是抽取重复的内容，然后通过索引来引用这些重复的内容。</p>
<p>将所有的xml文件都编译完成后，就可以输出resources.arsc 和 R.java 文件了，由于在之前的步骤中，我们已经将所有的资源保存在了ResourceTable这个结构中，那么接下来只需要遍历这个结构，按照资源出现的顺序将最终的资源id写入R.java,然后按照arsc文件的结构把ResourceTable中的内容写入文件就得到了resource.arsc文件。需要注意一点，arsc文件的结构并不是aapt定义的，而是由Android系统源码中的AssetManager定义，因为这份文件最终是由AssetManager来读取和解析的。</p>
<h3 id="0x01-resources-arsc-结构分析"><a href="#0x01-resources-arsc-结构分析" class="headerlink" title="0x01 resources.arsc 结构分析"></a>0x01 resources.arsc 结构分析</h3><p>我们通过ResourceTypes.h 的定义来分析arsc的结构，为什么不通过aapt创建它的过程来分析呢，因为aapt的代码实在太难读。。。</p>
<p>arsc文件的结构如图所示</p>
<p><img src="http://i2.piimg.com/567571/3efd8cca9f242183.png" alt="arsc文件结构"></p>
<p>其中ResTable_typeSpec结构描述了资源的类型，例如drawable，layout。<br>ResTable_type结构描述了不同相同类型的资源在不同的维度下的配置，这里的维度指的就是Android平台提供的资源适配机制，比如drawable-xhdpi,drawable-xxhdpi描述的是屏幕密度，layout-v19,layout-v21描述的是系统版本，Android系统一共提供了18个维度来进行资源适配，具体的内容可以参考文档。AssetManager会根据实际运行时的设备信息匹配到最合适的资源。entry结构描述的是具体的资源项，在不同的 <code>ResTable_type</code>下的一组entry是同名资源在不同维度下的不同文件。理论上每一个<br><code>ResTable_type</code>下包含有相同个数的entry，但是实际上并不会这样，因为我们往往只针对部分资源做了不同维度的区分，这意味着每一个type下的entry数组是不等长的，对于这样的情况，AssetManager有一套机制来对维度进行剪裁，具体算法可以参考文档。</p>
<p>注意一点，值字符串常量池没有根据包名进行区分，所有包中的资源的值字符串都会进入这个区域。而其他的区域是根据包名进行区分的，但是很奇怪的一点是，在我的测试中，无论是使用gradle进行构建，还是直接使用aapt打包，都无法做到在resource.arsc中包含多个package。使用gradle时只包含一个包这个很好理解，因为gradle在调用aapt之前已经将多个包中的资源进行合并，aapt接受到的参数中只有一个包。但是使用aapt的–auto-overlay和–extra-packages参数依然只包含一个包，让我很困惑，后续还会继续阅读aapt的代码查找原因。</p>
<p>对于编译时资源文件的处理就分析到这，省略了很多细节，对具体的细节感兴趣的话，可以参考老罗的系列博客，写的很详细。</p>
<h3 id="0x02-运行时资源寻找过程"><a href="#0x02-运行时资源寻找过程" class="headerlink" title="0x02 运行时资源寻找过程"></a>0x02 运行时资源寻找过程</h3><p>首先我们回想一下在Activity中我们是如何获取定义在strings.xml文件中的字符串的，就是以下方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MainActivity.java</span></div><div class="line">String str = getResources().getString(R.string.app_string_2_1);</div></pre></td></tr></table></figure>
<p>我们来分析一下调用链，<br>首先getResources()方法是在Context中定义的抽象方法，Context的继承关系如图所示：</p>
<p><img src="http://i4.piimg.com/567571/5a0c8aed9fd9b402.png" alt="Context继承关系"></p>
<p>在Activity中的getResources()方法会走到ContextWrapper的实现上，而ContextWrapper顾名思义它只是一个包装类，最终的调用是ContextWrapper的实际类ContextImpl中的方法。</p>
<p>ContextImpl中getResources()方法返回了它的成员变量mResource,我们看一下ContextImpl的构造函数，其中mResources被第一次赋值是通过下面的函数调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Resources resources = packageInfo.getResources(mainThread);</div></pre></td></tr></table></figure>
<p>packageInfo是一个LoadedApk类型的参数，mainThread是ActivityThread类型的参数，mainThread就是当前Apk运行的主进程类，我们继续看LoadedApk中的方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">(ActivityThread mainThread)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mResources == <span class="keyword">null</span>) &#123;</div><div class="line">        mResources = mainThread.getTopLevelResources(mResDir, mSplitResDirs, mOverlayDirs,</div><div class="line">                mApplicationInfo.sharedLibraryFiles, Display.DEFAULT_DISPLAY, <span class="keyword">null</span>, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mResources;</div></pre></td></tr></table></figure>
<p>继续往下走到AcitvityThread中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Creates the top level resources for the given package.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function">Resources <span class="title">getTopLevelResources</span><span class="params">(String resDir, String[] splitResDirs, String[] overlayDirs,</span></span></div><div class="line"><span class="function"><span class="params">        String[] libDirs, <span class="keyword">int</span> displayId, Configuration overrideConfiguration,</span></span></div><div class="line"><span class="function"><span class="params">        LoadedApk pkgInfo)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mResourcesManager.getTopLevelResources(resDir, splitResDirs, overlayDirs, libDirs,</div><div class="line">            displayId, overrideConfiguration, pkgInfo.getCompatibilityInfo(), <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>mResourceManager是一个ResourceManager类型的成员变量，当我们戳开ResourceManager的代码时，惊喜的发现这个类是一个单例，然后定位到getTopLevelResources方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">这个方法有点长，我删减了一些不太关键的逻辑</div><div class="line">ResourcesKey key = <span class="keyword">new</span> ResourcesKey(resDir, displayId, overrideConfiguration, scale, token);</div><div class="line">Resources r;</div><div class="line">WeakReference&lt;Resources&gt; wr = mActiveResources.get(key);</div><div class="line">r = wr != <span class="keyword">null</span> ? wr.get() : <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; r.getAssets().isUpToDate()) &#123;</div><div class="line">    <span class="keyword">return</span> r;</div><div class="line">&#125;</div><div class="line">AssetManager assets = <span class="keyword">new</span> AssetManager();</div><div class="line"><span class="keyword">if</span> (resDir != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (assets.addAssetPath(resDir) == <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line">r = <span class="keyword">new</span> Resources(assets, dm, config, compatInfo, token);</div><div class="line">WeakReference&lt;Resources&gt; wr = mActiveResources.get(key);</div><div class="line">Resources existing = wr != <span class="keyword">null</span> ? wr.get() : <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; existing.getAssets().isUpToDate()) &#123;</div><div class="line">    r.getAssets().close();</div><div class="line">    <span class="keyword">return</span> existing;</div><div class="line">&#125;</div><div class="line">mActiveResources.put(key, <span class="keyword">new</span> WeakReference&lt;Resources&gt;(r));</div><div class="line"><span class="keyword">return</span> r;</div></pre></td></tr></table></figure>
<p>最终我们找到了Resources对象创建的地方，接下来我们看获取到Resources后如何找到对应id的资源，在Resources中定位到getString(int id)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(@StringRes <span class="keyword">int</span> id)</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</div><div class="line">    <span class="keyword">final</span> CharSequence res = getText(id);</div><div class="line">    <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> res.toString();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(<span class="string">"String resource ID #0x"</span></div><div class="line">                                + Integer.toHexString(id));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着往下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> CharSequence <span class="title">getText</span><span class="params">(@StringRes <span class="keyword">int</span> id)</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</div><div class="line">     CharSequence res = mAssets.getResourceText(id);</div><div class="line">     <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">return</span> res;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(<span class="string">"String resource ID #0x"</span></div><div class="line">                                 + Integer.toHexString(id));</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>注意到寻找资源的调用是有AssetManager来执行的。这个AssetManager对象是在ResourceManager中创建并传递给Resources中的，java层的AssetManager只是Native层AssetManager的一个代理，其中初始化，获取资源的方法都是native实现，java层的AssetManager通过持有Native对象的内存地址来和Native对象进行通信。我们再来看ResourceManager中对AssetManager的使用方式，发现ResourceManager只为AssetManager设置了资源路径，这个路径实际就是Apk文件的路径。</p>
<p>分析到这里，我们其实已经找到了在运行时注入资源的方式，有两个思路，第一，当我们需要加载插件中的资源时，替换掉当前Context的ContextImpl中的Resource对象。第二，由于ResourceManager是一个单例类，并且持有了当前App的Resource缓存，那么我们直接在App启动时手动替换掉ResourceManager中的Resource缓存，就可以在当前App中添加插件的资源，并且全局有效。</p>
<h3 id="0x03-实例分析"><a href="#0x03-实例分析" class="headerlink" title="0x03 实例分析"></a>0x03 实例分析</h3><p>下面我们来实验一下刚刚得到思路，这里我们采用第一个思路，也就是只替换当前Context的Resource对象。</p>
<h4 id="创建plugin"><a href="#创建plugin" class="headerlink" title="创建plugin"></a>创建plugin</h4><p>首先创建接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ILib.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILib</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">getLibString</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//LibComponent.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LibComponent</span> <span class="keyword">implements</span> <span class="title">ILib</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Context context;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LibComponent</span><span class="params">(Context context)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.context = context;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLibString</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.e(<span class="string">"lib_plugin"</span>,Integer.toHexString(R.string.app_1_string));</div><div class="line">        <span class="keyword">return</span> context.getString(R.string.app_1_string);<span class="comment">//输出的内容是"111111ypp1"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="创建host"><a href="#创建host" class="headerlink" title="创建host"></a>创建host</h4><p>App启动时将Asset目录下的插件拷贝到App的存储目录<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//HostApplication.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installPluginApk</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   InputStream inputStream = getResources().getAssets().open(<span class="string">"lib_plugin.apk"</span>);</div><div class="line">                   File apkFile = <span class="keyword">new</span> File(getFilesDir(),<span class="string">"lib_plugin.apk"</span>);</div><div class="line">                   OutputStream out = <span class="keyword">new</span> FileOutputStream(apkFile);</div><div class="line">                   <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">                   <span class="keyword">int</span> len;</div><div class="line">                   <span class="keyword">while</span>((len=inputStream.read(buf))&gt;<span class="number">0</span>)&#123;</div><div class="line">                       out.write(buf,<span class="number">0</span>,len);</div><div class="line">                   &#125;</div><div class="line">                   inputStream.close();</div><div class="line">                   out.close();</div><div class="line">                   installSuccess.set(<span class="keyword">true</span>);</div><div class="line">               &#125;<span class="keyword">catch</span> (IOException e)&#123;</div><div class="line">                   e.printStackTrace();</div><div class="line">                   installSuccess.set(<span class="keyword">false</span>);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;).start();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>修改当前Context的Resource，注入插件的资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MainActivity.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">injectContextResource</span><span class="params">()</span></span>&#123;</div><div class="line">    AssetManager assetManager = ReflectAccelerator.newAssetManager();</div><div class="line">    String[] paths = <span class="keyword">new</span> String[<span class="number">2</span>];</div><div class="line">    paths[<span class="number">0</span>] = getPackageResourcePath();</div><div class="line">    paths[<span class="number">1</span>] = getFilesDir()+File.separator+<span class="string">"lib_plugin.apk"</span>;</div><div class="line">    ReflectAccelerator.addAssetPaths(assetManager,paths);</div><div class="line">    Resources base = getResources();</div><div class="line">    DisplayMetrics displayMetrics = base.getDisplayMetrics();</div><div class="line">    Configuration configuration = base.getConfiguration();</div><div class="line">    Resources injectResource = <span class="keyword">new</span> Resources(</div><div class="line">            assetManager,</div><div class="line">            displayMetrics,</div><div class="line">            configuration</div><div class="line">            );</div><div class="line">    ReflectAccelerator.setResources(getBaseContext(),injectResource);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建ClassLoader加载插件中的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MainActivity.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getLibText</span><span class="params">()</span></span>&#123;</div><div class="line">    File source = <span class="keyword">new</span> File(getFilesDir()+File.separator+<span class="string">"lib_plugin.apk"</span>);</div><div class="line">    DexClassLoader cl = <span class="keyword">new</span> DexClassLoader(</div><div class="line">            source.getAbsolutePath(),</div><div class="line">            <span class="keyword">this</span>.getCacheDir().getPath(),</div><div class="line">            <span class="keyword">null</span>,</div><div class="line">            getClassLoader()</div><div class="line">    );</div><div class="line">    Class libPlugin = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//省略异常处理</span></div><div class="line">        libPlugin = cl.loadClass(<span class="string">"com.haizhi.oa.restest.LibComponent"</span>);</div><div class="line">        Class[] paramTypes = <span class="keyword">new</span> Class[]&#123;</div><div class="line">                Context.class</div><div class="line">        &#125;;</div><div class="line">        Constructor constructor = libPlugin.getConstructor(paramTypes);</div><div class="line">        injectContextResource();<span class="comment">//注入资源</span></div><div class="line">        ILib iLib = (ILib)constructor.newInstance(getBaseContext());</div><div class="line">        String res = iLib.getLibString();</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>反射工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ReflectAccelerator.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AssetManager <span class="title">newAssetManager</span><span class="params">()</span> </span>&#123;</div><div class="line">       AssetManager assets;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           assets = AssetManager.class.newInstance();</div><div class="line">       &#125; <span class="keyword">catch</span> (InstantiationException e1) &#123;</div><div class="line">           e1.printStackTrace();</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125; <span class="keyword">catch</span> (IllegalAccessException e1) &#123;</div><div class="line">           e1.printStackTrace();</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> assets;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] addAssetPaths(AssetManager assets, String[] paths) &#123;</div><div class="line">       <span class="keyword">if</span> (sAssetManager_addAssetPaths_method == <span class="keyword">null</span>) &#123;</div><div class="line">           sAssetManager_addAssetPaths_method = getMethod(AssetManager.class,</div><div class="line">                   <span class="string">"addAssetPaths"</span>, <span class="keyword">new</span> Class[]&#123;String[].class&#125;);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (sAssetManager_addAssetPaths_method == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">return</span> invoke(sAssetManager_addAssetPaths_method, assets, <span class="keyword">new</span> Object[]&#123;paths&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setResources</span><span class="params">(Context context, Resources resources)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (sContextImpl_mResources_field == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">           sContextImpl_mResources_field = getDeclaredField(</div><div class="line">                   context.getClass(), <span class="string">"mResources"</span>);</div><div class="line">           <span class="keyword">if</span> (sContextImpl_mResources_field == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       setValue(sContextImpl_mResources_field, context, resources);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="资源冲突的现象"><a href="#资源冲突的现象" class="headerlink" title="资源冲突的现象"></a>资源冲突的现象</h4><p>实际运行一下，结果如下：</p>
<p><img src="http://i4.piimg.com/567571/7425928853951073.png" alt=""></p>
<p>呃，非常的尴尬，没有按照我们设想的那样输出”111111ypp1”,这是为什么呢？</p>
<p>猜测一下原因，我们在注入资源的时候放入了两个path路径，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">paths[<span class="number">0</span>] = getPackageResourcePath();</div><div class="line">paths[<span class="number">1</span>] = getFilesDir()+File.separator+<span class="string">"lib_plugin.apk"</span>;</div></pre></td></tr></table></figure>
<p>path[0]是宿主的资源，path[1]是插件资源，假如宿主和插件的资源id相同，由于宿主的资源路径在插件的前面，那么AssetManager会首先命中宿主的资源，于是返回了宿主的资源。<br>我们调整一下path的顺序，验证一下我们的猜测。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">paths[<span class="number">1</span>] = getPackageResourcePath();</div><div class="line">paths[<span class="number">0</span>] = getFilesDir()+File.separator+<span class="string">"lib_plugin.apk"</span>;</div></pre></td></tr></table></figure>
<p>调整顺序后，正确返回了插件的资源。</p>
<p><img src="http://i1.piimg.com/567571/bb165e5dccfd9f62.png" alt=""></p>
<p>对比一下插件和宿主的R.java文件，我们发现插件中R.string.app_1_string的资源id是0x7f040000,在宿主中，同样id对应的资源为R.layout.abc_action_bar_title_item 它的值是res/layout/abc_action_bar_title_item，再次验证了我们的猜测。</p>
<h4 id="如何解决资源冲突"><a href="#如何解决资源冲突" class="headerlink" title="如何解决资源冲突"></a>如何解决资源冲突</h4><p>要解决资源冲突，目前有很多插件化框架都提出了自己的解决方案</p>
<ol>
<li>宿主和插件隔离</li>
</ol>
<p>我们在加载插件Activity时，只在当前上下文注入插件的资源，这样宿主和插件之间是完全隔离的，也就无所谓资源id冲突了。</p>
<ol>
<li>通过public.xml锁死宿主资源id</li>
</ol>
<p>在编译宿主时，手动指定宿主中所有资源的id，然后在编译插件时，通过在public.xml中设定padding，避免分配到宿主的资源id</p>
<ol>
<li>修改aapt,增加packageId参数</li>
</ol>
<p>在前文的分析中，我们知道资源id是通过0xPPTTEEEE的形式指定的，如果在编译插件资源时，指定插件的packageId不是0x7f，而是指定的值，那么即使TTEEEE重复，也能保证整个资源id不重复。</p>
<ol>
<li>修改resource.arsc</li>
</ol>
<p>这种方案和第三种是同样的原理，都是修改packageId，只是是从resources.arsc文件出发。</p>
<p>下面我们尝试一下直接修改resource.arsc的方案。由于需要修改aapt生成的R.java文件，因此我们不使用gradle构建，使用appt,javac,dx手动打包。</p>
<p>首先修改R.java,指定packageId为0x7e</p>
<p><img src="http://i1.piimg.com/567571/b57ad2249b26d40a.png" alt=""></p>
<p>然后修改resource.arsc中的packageId</p>
<p><img src="http://i1.piimg.com/567571/434052c0f6b26d50.png" alt=""></p>
<p>解释一下这几个值的含义：</p>
<p><em>Chunk_Type</em> 由于resource.arsc中的内容是分块的，chunk_type表示当前数据块的类型。</p>
<p><em>Header_Size</em> 每一种类型的数据块都有一个头部，header_size表示当前数据块头部的大小</p>
<p><em>Chunk_Size</em> 当前数据块的大小</p>
<p><em>Package_ID</em> 当前package的ID</p>
<p>理论上要修改packageid不仅仅需要修改resources.arsc中的packageid，还要修改所有编译后的xml中的相关内容，这里我们先考虑最简单的情况，在插件资源中只包含values类型。我们将编译好的resource.arsc文件中的0x7f000000修改为0x7e000000。</p>
<p>然后按照正常的步骤打包插件。在宿主中运行，R.string.app_1_string对应的资源id变为0x7e040002,同时正确输出了”111111ypp1”。</p>
<p><img src="http://i1.piimg.com/567571/e892a4b8db6553d4.png" alt=""></p>
<h3 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h3><p>上述的分析其实只回答了我们一个问题，为什么我们在做插件化开发的时候，要对资源id进行特殊的处理。除开宿主和插件隔离的方案，无论是携程的实现还是Small的实现，都采用了手动分配PP段，保证资源id不重复。</p>
<p>我对这个问题的理解是这样的，宿主和插件，插件和插件之间进行资源共享对于插件化开发而言并不是必须的，假设宿主和插件之间隔离，带来的问题是同样的资源会在多个插件中重复出现，导致应用的整体体积膨胀，但是我们可以规避复杂的资源id处理部分，不做，就不会有bug。</p>
</div><div class="tags"></div><div class="post-nav"><a href="/Zygote进程的启动过程/" class="pre">Zygote进程的启动过程</a><a href="/插件化之aapt源码阅读笔记/" class="next">插件化之aapt源码阅读笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Gradle/">Gradle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactNative/">ReactNative</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作/">工作</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/插件化/">插件化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机/">计算机</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">chenlong's.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>